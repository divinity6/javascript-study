/**
  * 프로그램 설명문서 주석
  * 2021.01.21 수업
  * 
  * ====== 빌트인 오브젝트 구조 ========
  * 
  *      - 오브젝트 이름(Object ,String ,Number...)
  * 
  *      - 오브젝트.prototype
  * 
  *      ---> 인스턴스 생성 가능 여부 기준
  * 
  *      -------> 프로토 타입이 있으면 인스턴스를 생성할 수 있고 없으면 
  *      -------> 인스턴스를 생성할 수 없다.
  * 
  *      ---------> 예) Number 오브젝트에는 프로토 타입이 있다
  *      ---------> 그렇지만 수하계산용 오브젝트인 Math 오브젝트에는 프로토 타입이 없다
  *      ---------> 따라서 Math 오브젝트는 인스턴스를 만들 수 없다.
  *      
  *      --> 또한 prototype은
  * 
  *      ---> 프로퍼티를 연결하는 오브젝트
  * 
  * 
  *      - 오브젝트.prototype.constructor
  *        
  *      -------> 프로토 타입에 이처럼 .을찍고 프로퍼티를 연결합니다.
  *      -------> 이것이 프로토 타입의 기능이다.
  * 
  *      ---------> *다시한번 정리하면 프로토타입이 있으면 인스턴스를 생성 할 수있고
  *      ---------> 여기에 프로퍼티를 연결 하는 것이다.
  *      ---------> 이것이 기준이다.
  * 
  *      -------> 오브젝트.prototype.constructor
  *      -------> 여기서 constructor 은 시멘틱그대로 생성자 이다.
  *      ---------> 우리가 new Number 하게되면 new Number로 생성자 함수를 호출하게 된다.
  *      ---------> 생성자함수는 내부에서 '오브젝트.prototype.constructor'를 호출한다.
  *      ---------> 따라서 constructor 가 실질적으로 인스턴스를 생성하게 되는 것 이다.
  * 
  *      -------> 이런 역할을 하게된다.
  *      ---------> 그래서 prototype이 없으면 constructor는 존재하지 않는다
  *      ---------> 따라서 인스턴스를 생성할 수 없게되는 것이다.
  *      ---------> 그런데 prototype이 있으면 constructor는 디폴트로 따라 붙는다.
  * 
  *      -------> 따라서 prototype의 존재여부로 인스턴스르 생성여부를 가늠할 수 있는 기준은 논리적이다.
  * 
  *      ---> 오브젝트의 생성자
  * 
  * 
  *      - 오브젝트.prototype.method
  * 
  *      ----> 여기에 다수의 method를 작성할 수 있다.
  *      -------> 지금 method 라고 했다. 지금까지 method라고 안쓰고 함수란 말을 썻다
  *      -------> 함수와 method의 차이에 대해서는 다음장에서 다루겠다.
  *      
  *      ---> 메소드 이름과 함수 작성
  * 
  *      - 오브젝트 구조
  * 
 */
console.log("=====================================");
window.onload = function() {
   "use strict"
   debugger;
   
   var obj = Object;



   /*
   1. obj에 Object 빌트인 오브젝트가 할당된다
   
   2. 오른쪽 Local의 obj를 펼친다
   -  빌트인 Object 오브젝트에 포함된 프로퍼티이다.
   -  assign: f assign() 처럼 표시된 것이 함수이다
   ---> 물론 이것도 프로퍼티긴 하지만 함수를 나타내는 것이다
   -  Length: 1, name: "Object" 처럼 표시된 것이 프로퍼티 이다
   ---> 이프로퍼티는 key와 value,
   */
  debugger;

   var proto = Object.prototype;
   /*
   3. prototype을 펼친다
   4. constructor가 있으며 f Object()이다
   - 이것은 시맨틱 그대로 생성자이다.

   --> 즉 Object 생성자함수를 호출하면 내부에서 이 constructor를 호출한다
   ----> constructor를 펼쳐보겠다
   ------> 위의 빌트인 Object obj와 (내부구조가)같다
   ------> constructor에 빌트인 오브젝트 전체가 assign(할당) 되어있다

   ----> 즉, 같다는 이야기다

   ------> 그래서 이것을 호출하면 인스턴스를 만들 수 있다.
   ------> 물론 이 생성자에도 프로토 타입이 있다. 
   --------> 심지어 이 prototype마저도 같다 (6개의 함수가있는것도 같다)
   --------> 그니깐 인스턴스를 만들면서 여기에(constructor.prototype안에) 있는 것을 가지고 
   --------> 인스턴스.__proto__.에 연결시켜주는 것이다

   5. new Object()를 하거나 var obj = {};를 실행하면
   - 생성자가 호출되어 Object 인스턴스를 만든다

   6. ES5에서는 constructor를 변경할 수 없지만
   -  ES6에서는 변경할 수 있다.

   --> 따라서 사용성이 굉장히 높아진 것이다.
   
   
   */

  debugger;
  /*
  
      - 빌트인 오브젝트 구조를 다시한번 정리해보면

      -- 우선 오브젝트 이름(Object,String,Number...)이 있어야하고

      -- 여기에 오브젝트의 프로토타입이 있어야한다.

      -- 물론 없을수도 있고 있으면 여기에 인스턴스를 만들수있는것이다.

      -- 그리고 prototype에다가 프로퍼티를 연결한다
      -- (오브젝트.prototype.constructor나 오브젝트.prototype.method 처럼) 

      -- 자바스크립트에서 prototype은 굉장히 중요한 의미를 갖지만

      -- 실제 기능적으로 보면 별거 없다.

      -- 그냥 인스턴스를 만드는 기준 역할,

      -- 그리고 프로퍼티를 연결하는 역할,

      -- 오브젝트다 결국.

      -- 그렇지만 JS개발자들에게는 prototype이 굉장히 중요한 의미를 갖는다고 화자된다

      -- 하지만 안의 내용을 본다면 별거없다는 것이다


      -- 오브젝트.prototype.constructor은 생성자 함수라는 것

      -- 실제로 우리가 new Number에서 생성자 함수를 호출하면

      -- 엔진은 constructor를 호출하여 인스턴스를 만든다는 것이다.

      -- *'그리고 prototype에 연결되어있는 함수를 method라고한다.'
      
  */
 debugger;

}



