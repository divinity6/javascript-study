/**
  * 프로그램 설명문서 주석
  * 2021.03 06 수업
  * 
  *           
  *           ===== parse() =====
  *         
  *        - 구분             - 데이터(값)
  * 
  *        - object           - JSON 오브젝트
  *        - 파라미터          - 변환 대상
  *                           - 파싱 데이터로 실행할 함수 opt
  *        - 반환              - 변환 결과
  * 
  *        --------------------------------------------------
  * 
  *        - JSON 타입을 JS 타입으로 변환
  * 
  *        - 작성 주의
  *        ----> "123."을 "1231.0" 으로 작성
  *        ----> "0123" 처럼 첫 자리에 0 사용 불가
  *        ----> 대문자 "NULL" 사용 불가, "null" 사용
  *        ----> 10진수 사용
  * 
  *        --------------------------------------------------------
  * 
  * 
  */
 console.log("=====================================");
 
 window.onload = function() {
   "use strict"
   // console.log 사용
   var log = function( value , key ){
     if ( key === "note") {
       console.log('--- ' + value +' ---');
      } else { console.log(value); }
  };

  log('값이 숫자일 때' ,'note');

  var value = "123";
  try {
    var result = JSON.parse( value );
  } catch(e) {
    console.log( "JSON 파싱 에러");
  }
  console.log( result );
  // :: 123
  console.log( typeof result );
  // :: number

  // 1. JSON 형태는 기본적으로 큰 따옴표를 사용한다
  // 2. 즉, String 타입이지만
  //    JSON.parse()에서 JS 타입에맞도록 변환
  // 3. "123"은 문자열이지만 값이 숫자이므로
  //    Number 타입의 숫자로 변환
  // 4. 파싱 대상이 서버에서 받은 데이터일 때, try-catch 사용은 필수이다.

  /*
      - 문자열이 Number 타입으로 변경되었다.
        에러도 안났는데 try-catch문을 작성한 이유는

      - 서버에서 데이터를 가져오는 동안에는 어떤일이 발생할지 모른다.
        따라서 서버에서 데이터를 수신할때는, 전송할때는 반드시

        [[try-catch문안에 작성]]해야 한다.

      - 이것은 필수이다.
        쉽게 이야기하면 보험을 들어 놓는것(에러를 방지하기 위함, 안그러면 프로그램이 죽으니깐)
  */

  log('true , false','note');
  var value = "true";
  var result = JSON.parse( value );

  console.log( result );
  // :: true
  // 1. "true"도 숫자처럼 true로 변환
  console.log( typeof result );
  // :: boolean
  // 2. 설명 편의를 위해 try-catch를 사용하지 않았으나
  //    [[try-catch 사용은 필수다.]]


  log('배열에 작성' , 'note');
  var value = '[ "ABC" , "가나" , "12" ]';
  var result = JSON.parse( value );
  console.log( result );
  // ::  ["ABC", "가나", "12"]
  // 1. 배열에 작성된 String 타입의 숫자는 숫자로 변환하지 않는다.

  /*
      - JSON은 일반적으로 배열안에 작성한다.
        물론 오브젝트안에 작성하는 경우도있다.

      - 그러나 데이터가 많으면 오브젝트만으로는 좀 그렇다.

      - 다량의 데이터를 받으려면 배열인 것이다!
        그리고 배열안에 오브젝트를 작성해서 네임밸류형태로 만들어내면 된다.

      - 따라서 배열을 많이 작성한다. 그런데 앞과다르게 문자열로 12가 그대로 나온다

      ------------------------------------------------------------------------

      - 테이터가 숫자 하나일 경우에는 이것을 Number타입으로 바꾸지만 배열안에 작성하면 ,
        그렇지 않을경우에는 String 타입이 된다.
        '[ "ABC" , "가나" , "12" ]' 이형태는 거의 JSON이다.

      - 따라서 이부분에 대해서는 신경을 써야한다.

      - 보통 데이터를 파싱한 부분을 읽었을 때, 
        읽으면서 이값이 Number인지 물어보는 것이 일반적이다
        그렇지않으면 예를들어 parseInt() 나 parseFloat()이나 그렇지않으면 Number()나
        이런함수로 변환을 시도해 보는 것이다.

        그렇지않으면 이값을 연산을 못하지 않는가.(그런 어떤 측면)
  */

  log('Object에 작성' , 'note');

  var value = '{"point" : "123"}';
  var result = JSON.parse( value);

  console.log( result );
  // :: {point: "123"}

  // 1. JS는 프로퍼티 이름에 큰따옴표를 사용하지 않으므로 큰 따옴표가 표시되지 않음

  /*
      - 프로퍼티 값이 숫자라도 String타입이면 그냥 String 타입으로 온다.
        따라서 오브젝트나 배열안에 작성한 것은 전부다 그대로 온다라는 것.

      - 그런데 문자열로 작성한 오브젝트이름이 큰따옴표가 없어졌다.
        이것이 바로 [[자바스크립트 타입]]으로 변환한 것이다

      - 물론, 다른내용도 포함되어 있지만 큰따옴표가 지워지고 변환된다.

      - 그러나 주의할 사항이 좀 있다. ( JSON --> JS )

      ----> "123."보단 "123.0"으로 작성
      ----> "0123" 처럼 첫자리에 0 사용 불가
      ----> 또한 대문자 "NULL"이 아닌 소문자 "null"로 작성
      ----> 또한 10진수 사용( 16진수같은것을 사용할 수 없다는 뉘앙스 )
  */

    debugger;

    /*
              ===== parse() =====
    
          - 두 번째 파라미터 작성

          - 첫 번째 파라미터의 JSON 문자열을 파싱하면
          ----> { book : "책" , movie: "영화" } 형태가 된다

          - 파싱한 오브젝트를 하나씩 읽어가면서
            두 번째 파라미터의 함수를 실행

          - 함수에서 값을 반환하면
            파싱 결과인 result 변수에 반영

          - 값을 반환하지 않거나 undefined를 반환하면
            프로퍼티가 제외되므로 반환해야 한다.
    
    */

    var data = '{"book" : "책" , "movie" : "영화"}';
    var check = function( key , value) {
      var sum = key === "book" ? "JS책" : value
      // 처음한두번은 key= "book" , value ="책" 이런식으로들어오다 마지막에 전체를 할당해 뻐리는구나
      // 마지막에 여기로 key = "", value = {book: "JS책", movie: "영화"} 이형태로 들어오네

      return sum;
    };
    // 1. 프로퍼티 이름이 "book" 이면 "책"을 "JS책"으로 바꾼다.
    var result = JSON.parse( data , check );
    console.log( result );
    // :: {book: "JS책", movie: "영화"}

    /*
      - check 에서 반환될때는 프로퍼티가 반환이된다.
        그러면서 {book: "JS책", moview: "영화"}와 같이
        큰따옴표가 없어지는 형태가 된다.

      - 그런데 [[값을 반환하지 않거나 undefined를 반환]] 하면 프로퍼티가 날라가버린다
        (제외된다.) 따라서 result 변수에 할당이 안된다.

      - 우리의 생각 :: 리턴안시키면,( 리턴문 작성을 안하면 ) 읽은 부분 그냥
                      반환시켜 주면 되지 않는가.

        라는 생각이 들지만 어떻겠는가, 규칙이다.

      ==== 즉, 반환할 것이 없더라도 value(값)를 반환 시켜줘야한다. 아, value!!
        value를 반환시켜줘야한다!( 이것이 프로퍼티로 반환되는 구나 ) =====

      - 그렇지않으면 날라가 뻐린다
        ( 두 번째 파라미터에 함수를 작성할 때는 이부분을 신경 써야한다. )  
    */
};
