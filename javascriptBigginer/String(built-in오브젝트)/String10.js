/**
  * 프로그램 설명문서 주석
  * 2021.01.16 수업
  * 
  *     ======== cahrCodeAt() ========
  * 
  *     - 구분                  - 데이터(값)
  * 
  *     - data                  - 반환 대상
  * 
  *     - 파라미터              - 반환 기준 인덱스(Index)
  * 
  *     - 반환                  - 인덱스 번째 문자
  * 
  *     ---------------------------------------
  *
  *     -- 인덱스 번째의 문자를
  *         유니코드의 코드 포인트 값(사전)을 반환
  * 
  *     -- 인덱스가 문자열 길이보다 크면
  *         NaN 반환 
  * 
 */

console.log("=====================================");
window.onload = function() {
  "use strict"
  debugger;
  
  var value = "1Aa가";
  for (var k = 0; k < value.length; k ++){
    console.log(value.charCodeAt(k));
  };
  console.log(value.charCodeAt(12));
  
  // 1. charCodeAt(12)에서
  //    12번째가 없으며 NaN 반환
  
  
  debugger;


  /*
  
              - fromCharCode()

      - 구분                      - 데이터(값)

      - data                      - String 오브젝트

      - 파라미터                  - 유니코드, 다수 작성 가능

      - 반환                      - 변환한 문자

      ---------------------------------------------------
      
      -- 파라미터의 유니코드를
         문자열로 변환하고 연결하여 반환

      ----> 작성하지 않으면 빈 문자열 반환


      -- 작성 방법 --

      ----> data 위치에 String 오브젝트 작성
            변환 대상 값을 작성하지 않음

      ----> String.fromCharCode()형태
  */

  console.log(String.fromCharCode(49,65,97,44032));


/*

  1)  지금까지 파라미터에 있는 값을 변수등에 할당해서 함수(fromCharCode)앞에 작성했다.

      그러면 값의 타입이 String이면 엔진에서 new String 해서 인스턴스를만들고

      그 인스턴스의 fromCharCode 함수를 호출해서 처리를 했었다.

      그런데 이것은 그 형태가 아니다.

  
      함수 앞에 String 오브젝트 이름을 작성했고, 값을 파라미터에다 작성했다.

      그렇다면 이형태는 어떤형태인가?


  2)  프로토 타입이라는 것이 있었다.

      그것을 구분선으로 해서 프로토 타입에 연결되어 있는 함수들은 복사할때 복사본으로 해서 
      
      배포를 하지만 프로토 타입과 같은 레벨에 있는 것은 복사해 주지않고 종이로 가려서

      복사를 하고 배포하지 않는다.


  3)  그러면 그것은 원본을 와서 봐라! 라고했었다.

      그 원본에 속한 것이 바로 fromCharCode()함수 이다.

      따라서, 애는 복사한 것에 가있지 않고 원본을 봐야하니깐 원본의 이름인 
      
      bulit-in String 오브젝트 이름을 작성하게 된것이다.

      그래야 원본에 있는것이 불러 질 것이다.


  4)  그런데 그러면 왜 값을 파라미터에다 작성 했을까,
  
      함수위치, 앞에다 작성하면 안되는 것일까?

      안된다. 왜냐하면 어떻게 파라미터값(49, 65, 97, 44032)을 다 작성하겠는가

      하나는 문자열 49로해서 작성하면된다

      그러면 만약 49와 65는 어떻게 작성해야하는가

      이것은 배열형태로 작성해야한다.


  5)  그러면 어떻게 되는가. 이것은 타입이 배열이다.

      그렇기 때문에 bulit-in String 오브젝트에 있는 것을 부르지 않는다.

      왜냐하면 자바스크립트는 함수앞에 작성한 데이터 타입에 따라서 오브젝트를 호출하기 때문이다.

      배열이기 때문에 배열 오브젝트를 호출하게 되면 그곳에는 fromCharCode()가 없다.

      따라서 위와같은 형태를 취하게 된것이다.


  6)  즉, 파라미터에다가 다수를 작성할 수 있도록 원본의 함수를 작성한 것이다.

      자바스크립트의 구조에 따르다보니깐 어쩔수가 없는 것이다.

*/

  debugger;



  /* 
                - localeCompare()

      - 구분                          - 데이터(값)

      - data                          - 비교 대상

      - 파라미터                       - 비교할 값

      - 반환                          - 1(앞), 0(같음), -1(뒤)

      -------------------------------------------------------

      -- 값을 비교하여 위치를 나타내는 값으로 반환

      -- 위치 값 : 1(앞), 0(같음), -1(뒤)

      -- Unicode 사전(코드포인트 값) 순으로 비교
  
  */


  debugger;

  value = "나";

  console.log(value.localeCompare("가"));
  // 1. "가"가 "나" 보다 앞에 있으므로 1 반환
  console.log(value.localeCompare("나"));
  // 2. 비교 기준과 비교 대상이 모두 "나"이므로 0
  console.log(value.localeCompare("다"));
  // 3. "다"가 "나"보다 뒤에 있으므로 -1 반환

};



