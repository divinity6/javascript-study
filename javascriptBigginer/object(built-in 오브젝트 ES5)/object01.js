/**
  * 프로그램 설명문서 주석
  * 2021.02 28 수업
  * 
  *           
  *           ===== ES5 Object 특징 =====
  * 
  *           -- ES5 Object에 함수가 추가됨
  *           ----> 메소드는 하나도 없음 (모두 함수인 것이다)
  * 
  *           -- 빌트인 Object의 모든 메소드는
  *           ----> 대부분의 빌트인 오브젝트에 첨부됨
  *           ----> 빌트인으로 오브젝트를 생성하므로
  *                 연결이 많이 발생
  * 
  *           -- 함수는 첨부되지 않으므로
  *           ----> 연결 부하를 줄일 수 있음
  * 
  * 
  * 
  *           ----------------------------------------------------------------------
  * 
  *           - 위의 모든 것은 함수이다. 빌트인 Object의 모든 메소드(즉, 6개의 메소드).
  *             (프로토 타입에 연결되어 있는 것)들이
  * 
  *           - 대부분의 빌트인 오브젝트에 첨부된다
  *           (여기서의 빌트인 오브젝트란, 빌트인 String 오브젝트, 빌트인 Array 
  *           등등을 모두 총칭)
  * 
  *           - 그리고 이빌트인 오브젝트 가지고 오브젝트를 생성한다
  *           --> 예를 들어 배열을 만든다 그러면 빌트인 Array오브젝트로 만들고
  *           --> function을 만든다그러면 빌트인 Function 오브젝트로 만드는데 거기에는
  *               이 6개의 메소드가 있다는 것이다.
  * 
  *           - 그렇다고 6개의 메소드, 즉, toString, valueOf 이런 것들이 
  *             모든 것에 다쓰이는가?
  *             그렇지많은 않다
  * 
  *             결국 그것은 로스이다!
  * 
  *             왜냐하면 그것을 복사하는 것은 아니다. 
  *             함수를 복사한다는건 애기가 안된다
  *             빌트인 오브젝트로 만든 오브젝트에서 빌트인 오브젝트 Object에 prototype
  *             에 연결되어 있는 6개의 메소드를 호출할 수 있도록 경로를 만드는 것이다.
  * 
  *             그럼 어떤 조치를 취한다
  * 
  *             그럼 이걸 만들때마다 빌트인 가지고 만드는 모든 오브젝트에 그런것이 다
  *             들어간다? 이것은 로스다. 왜냐면 경로를 만든다는 그것은 메모리를 그만큼
  *             쓰게되는 것이다
  * 
  *           - 이런차원에서, 이런 발상에서 나온 함수들이다.(그래서 전부가 함수다)
  * 
  *           - 이것은 접근이 좋았다고 본다
  * 
  *           - String이나, Number나 그런 오브젝트에 메소드가 추가되는 것은 괜찮다
  *             왜냐면 그것은 하나의 오브젝트에 국한되기 때문이다
  * 
  *           ===== 그런데 빌트인 오브젝트 Object는 모든 오브젝트에 다들어간다 =====
  * 
  *           그래서 함수로 추가되면 연결 부하를 줄일 수 있다.(따라서 효율성이 높아진다)
  * 
  * 
  *           ----------------------------------------------------------------------
  * 
  *           ===== ES5 Object 함수 =====
  * 
  *           - 이름                        - 개요
  *     
  *           - defineProperty()            - 프로퍼티 추가, 프로퍼티 속성 변경
  *           - defineProperties()          - 다수의 프로퍼티 추가, 속성 변경
  *           - getPrototypeOf()            - prototype에 연결된 프로퍼티 반환
  *           - getOwnPropertyNames()       - 프로퍼티 이름을 배열로 반환
  *           - keys()                      - 열거 가능 프로퍼티 이름 반환
  *           - getOwnPropertyDescriptor()  - 디스크립터 속성 반환
  *           - preventExtensions()         - 프로퍼티 추가 금지 설정
  *           - isExtensible()              - 프로퍼티 추가 금지 여부 반환
  *           - seal()                      - 프로퍼티 추가, 삭제 금지 설정
  *           - isSealed()                  - 프로퍼티 추가, 삭제 금지 여부 반환
  *           - freeze()                    - 프로퍼티 추가, 삭제/변경 금지 설정
  *           - isFrozen()                  - 프로퍼티 추가, 삭제/변경 금지 여부 반환
  * 
  *           ----------------------------------------------------------------------
  *   
  *           -- defineProperty = define하다(정의하다), 무엇을? 프로퍼티를! 프로퍼티 정의
  *              ES5 Object에 새로 추가된 것이 속성 개념이다.
  *              "enumerable 같은 것이 속성이다"(열거할 수 있느냐, 없느냐)
  *           
  *           -- defineProperties 이것은 복수, 다수의 프로퍼티 정의
  * 
  *           -- getPrototypeOf = get! ~~의 프로토 타입에 연결된 프로퍼티 반환
  * 
  *           -- getOwnPropertyNames = 내가만든 프로퍼티 네임스들을 가져오는 것
  * 
  *           -- keys = 열거가능한 이름, key를 반환
  * 
  *           -- getOwnPropertyDescriptor()  = 이장에서 다룰 키워드이다! Descriptor!
  *              descriptor가 있다. 그런데 우리가 여태까지 다뤘던 것중에는 enumerable
  *              이라는 것이 있다. 아직까진 여기까지만 알면 된다
  * 
  *           -- preventExtensions() = prevent! 방지하다! 무엇을? Extensions 확장을!
  *              추가하는 것을 방지하는 것.
  *   
  *           -- isExtensible() = 추가 가능하니? 라고 물어보는 것
  *              
  *           -- seal()  = 애는 seal이다 preventExtensions 애는 추가만 금지지만 seal은
  *              삭제 까지 포함 한다. 
  *            
  *           -- isSealed() = 추가,삭제할수 없니?                
  *           -- freeze()  = 꽁꽁 얼어버리는 것, 변경까지도 못하는 것이다                 
  *           -- isFrozen()  = freeze 상태냐고 묻는 것     
  * 
  *           ----------------------------------------------------------------------
  * 
  *           ===== 프로퍼티 디스크립터 =====
  * 
  *           - 이름                      - 개요
  *       
  *           - value                     - [[Value]], 설정할 값
  *           - writable                  - [[Writable]], 값 변경 가능 여부
  *           - get                       - [[Get]], 값 반환 프로퍼티 함수
  *           - set                       - [[Set]], 값 설정 프로퍼티 함수
  *           - enumerable                - [[Enumerable]], 프로퍼티 열거 가능 여부
  *           - configurable              - [[Configurable]], 프로퍼티 삭제 가능 여부
  * 
  *           ----------------------------------------------------------------------
  *           
  *           -- 앞의 디스크립터 애기다. 6개의 디스크립터가 있다
  * 
  *           - value                     value는 우리가 {key : value}할때 
  *                                       value를 value라는 이름으로 해서 거기에 작성
  * 
  *           - writable                  값 변경 가능 여부를 true, false로 작성
  *                                       false로 주면 값을 변경할 수 없다.
  *                                       (데이터를 보호하겠다는 이야기)
  * 
  *           - get                       get은 함수이다. 이걸가지고 getter라고
  *                                       이야기를 한다.
  * 
  *           - set                       이것도 함수다. 값을 설정하는것 setter라고
  *                                       이야기를 한다.
  * 
  *           - enumerable                열거 가능 여부,
  * 
  *           - configurable              삭제 가능 여부
  * 
  *
  */
 console.log("=====================================");
 
 window.onload = function() {
   "use strict"
   // console.log 사용
   var log = function( value , key ){
     if ( key === "note") {
       console.log('--- ' + value +' ---');
      } else { console.log(value); }
  };
}
