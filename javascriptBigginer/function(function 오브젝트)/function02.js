/**
  * 프로그램 설명문서 주석
  * 2021.01.27 수업
  * 
  *      ====== 함수 분류 ========
  * 
  * 
  *      - function 분류
  *      ---> 빌트인 Function 오브젝트
  *      -----> 그야말로 빌트인이다(지금까지 하고있는)
  * 
  *      ---> function 오브젝트
  *      -----> function 오브젝트는 빌트인 Function 오브젝트로 만든다
  * 
  *      ---> function 인스턴스(new 연산자 사용)
  *      -----> function 인스턴스는 new 연산자를 사용하는데 앞전에서 다루었던
  *      -----> new Function은 문자열로 작성된것을 함수 코드로 만들면서 function 인스턴스를
  *      -----> 만들었다. 그러나 그때의 인스턴스는 위의 function 오브젝트에 해당한다.
  * 
  *      -----> 여기서의 function 인스턴스는 function 오브젝트를 new 연산자를 사용해서
  *      -----> 인스턴스를 만드는것을 뜻한다. 이에 대서는 뒤에서 다룬다.
  * 
  *      - function 오브젝트 생성 방법
  *      ---> function 키워드 사용
  *      ---> function getBook(title) {return title};
  *      -----> 이와같이 함수를 정의 한다.
  * 
  *      - JS 엔진이 function 키워드를 만나면
  *      ---> 이름이 getBook인 function 오브젝트 생성
  * 
  *      -----> 이때의 function 오브젝트는 위의 function 오브젝트(처음설명한)에 해당한다.
  *      -----> 물론 이것도 성격적으로는 빌트인 Function 오브젝트를 사용해서 만드므로
  *      -----> 인스턴스에 해당한다. 하지만 new 연산자가 아래에 있으므로 강좌에서는
  *      -----> function 오브젝트로 부르겠다는 뜻이다
  * 
 */
console.log("=====================================");

window.onload = function() {

   /*
                     - 함수 생명 주기

         - 함수 호출

         --> getBook("북");
         --> 함수를 호출하면서 파라미터 값을 념겨줌

         - 함수 코드 실행
         --> JS 엔진 컨트롤이 함수의 처음으로 이동
         ----> 여기서 컨트롤은 SPEC에 작성된 용어이다
         ----> 자바스크립트 엔진이 현재 처리하고있는 '위치'를 나타내는 뉘앙스이다
         
         --> 파라미터 이름에 넘겨 받은 파라미터 값 매핑
         ----> 호출한 함수에서 넘겨준 데이터 값을 호출받은 함수의 파라미터에 넘겨주는것

         --> 함수 코드 실행

         --> return 작성에 관계없이 반환 값을 갖고

         --> 함수를 호출한 곳으로 돌아감
         ----> 여기서는 return문을 작성했지만 return문을 작성하지 않아도 undefined가 반환된다

         --------------------------------------------------------------------

         -- 이러한 일련의 과정을 함수 생성 주기라고 한다
         -- 영어로 function life cycle 이라고 한다
   */
  "use strict"
  debugger;
  
   function getBook(title) {
     return title;
   };
   
   var result = getBook("JS북");
   console.log(result);
   
   /*
               - length 프로퍼티

         - 함수의 '파라미터 수'가
         --> 생성되는 function 오브젝트에 설정된다
         --> 함수를 호출한 곳에서 보낸
         --> 파라미터 수가 아니다

         - JS 엔진이 자동으로 설정한다
   */
   debugger;

   function add(one, two) {
      for(var i=0;i<add.length;i++){
         arguments[i];
         console.log('arguments :',arguments[i]);
      }
      return one + two;
   };
   // 파라미터 수가 2개이기 때문에 length 프로퍼티에 2가 설정된다
   console.log(add.length);
   // length 프로퍼티는 바로 액세스 할수 있다. add가 오브젝트이므로

   // (비록 function 오브젝트 이지만)add.찍고 값을 구할수 있는것이고

   // 위의 파라미터수가 2 이므로 2가 출력된다
   // (함수를 호출한 곳에서 보낸 파라미터 수가 아니다)

   debugger;
   
   add(1,2,3,4);
   // 1. add(1,2,3,4)로 호출하면
   //    one에 1이 설정되고 two에 2가 설정된다
   //-------> 그렇다고 3과 4가 날아가는 것은 아니다
   //-------> 어딘가에 저장이된다. 이에서는 뒤에서 다루겠다.

   //-------> 다만, 호출하는 파라미터의수와 호출받는 파라미터 수가
   //-------> 다른경우에는 호출되지 않는 언어도 있다. 물론 그나름대로 장점

   //-------> but 자바스크립트는 호출하는 파라미터의 수와 받는수가 같지않아도 된다.
   //-------> 또한 파라미터 갑의 타입이 같지 않아도된다.

   //-------> 일부 언어는 파라미터 값 앞에다가 타입을 작성한다.

   //-------> 자바스크립트는 호출하는 함수의 파라미터 수와 각각의 '값의 타입을 체크하지'
   //-------> '않고 함수를 호출'한다는 것
   //-------> 이러한 매커니즘을 갖고 있다.

   // 2. add() 함수를 호출한 곳에서 보낸
   //    값의 수가 아니다

   console.log(add.length);
   // 3. length 값은 4가 아니라 2이다.


   debugger;

}



