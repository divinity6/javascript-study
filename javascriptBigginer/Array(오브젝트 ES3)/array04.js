/**
  * 프로그램 설명문서 주석
  * 2021.02 03 수업
  * 
  *       ===== 엘리먼트 추가 =====
  *     
  *     - 배열에 엘리먼트를 추가하는 방법
  * 
  *     --> 삽입할 위치에 인덱스 지정
  *     --> 표현식으로 인덱스 지정
 */
console.log("=====================================");

window.onload = function() {
// "use strict" delete 사용불가

  var value = [1,2];
  // 1. 값을 설정하지 않은
  //    추가된 엘리먼트에 undefined 설정
  value[4] = 5;
  console.log(value);
  
  console.log('--- 표현식으로 인덱스 지정 ---');
  
  value = [1,2];
  // 1. 인덱스에 값을 더해 인덱스로 사용
  value[value.length + 2] = 5;
  // 이것도결국 위와 같다

  console.log(value);

  debugger;

  /*
          ===== delete 연산자 =====

      - 구분                      - 데이터(값)

      - object                    - 매치대상
      - 프로퍼티                  - 삭제할 프로퍼티 이름
      - 인덱스                    - 배열의 인덱스
      - 반환                      - 삭제 성공 : true, 실패 : false

      ------------------------------------------------------------

      -- var 변수는 삭제 불가

      -- 글로벌 변수는 삭제 가능

      -- { name : value } 삭제 방법

      ----> 삭제할 프로퍼티 이름 작성
      
      ----> ES5에서 삭제 불가 설정 가능

      -- 인덱스로 배열의 엘리먼트 삭제

      ------------------------------------------------------------------

      -- delete 연산자. 연산자이므로 배열에 속하는 것은 아니다
         delete에 속하는것을 묶어서 한꺼번에 다루려고 작성

      -- delete는 시멘틱 그대로 삭제한다. 삭제에 성공하면 true를 
         반환하고 실패하면 false를 반환한다.
  */

  var value = 123;
  // 1. var 변수를 삭제할 수 없다
  console.log(delete value);
  // 삭제 실패로 처리하여 false 반환

  /*
      variable 키워드를 사용해서 선언한 변수는 delete 연산자로 
      
      삭제할 수 없다. 한편 글로벌 변수는 삭제할 수 있다.
  */
 debugger;
 console.log('--- 글로벌 변수는 삭제 가능 ---');


  value2 = "글로벌 변수";
  console.log(delete value2);
  // 1. var 키워드를 사용하지 않은 글로벌 변수는 삭제할 수 있다.
  // 삭제를 성공해서 true를 반환

  // try가 예외가 발생하면 catch를 실행한다.
  try {
    console.log("시작",value2);
    // 삭제 확인하기 위해 value 변수 출력해봄
    // 변수가 없으므로 애러가 난다
  } catch(e) {
    console.log("존재하지 않음");
    // 2. 삭제하게 되어 true가 반환된다.
    // 에러가 나므로 catch문을 만나게 되어 존재하지 않음을 출력하게 된다
  }

  /*
      그런데 사실 var value = 123; 이것 또한 글로벌 변수이다. 
      함수안에 작성하지 않았기 때문에 이것도 글로벌 변수이다.

      그러나 var 키워드를 사용하면 delete연산자로 삭제 할 수 없다.
      var 키워드를 사용하지 않은  글로벌 변수는 삭제할 수 있다

      따라서 var 키워드를 사용하는 것은 필수라고 할 수 있다.

      strict 모드에서는 var 변수를 사용하지 않으면 에러가 난다.
      그래서 심플하게 변수를 선언할때는 var 키워드를 사용한다고 생각하면 간단하다
  */
  debugger;
  
 console.log('--- 오브젝트의 프로퍼티 삭제 ---');


  var book = {title:"책"};
  // 1. 오브젝트 이름.프로퍼티 이름 형태로 작성

  console.log(delete book.title);
  // 2. 오브젝트에 프로퍼티 이름이 없으면 undefined 반환
  console.log(book.title);
  // 변수는 타이틀이 없으면 에러가 나지만 프로퍼티로 접근할 때는 에러가
  // 나지않고 undefined가 출력된다


  debugger;

  console.log('--- 오브젝트 전체 삭제 ---');
  var book = {title : "책"};
  // 1. var 변수에 오브젝트를 할당하면 오브젝트 전체를 삭제할 수 없다
  console.log(delete book);

  sports = {item: "축구"};
  // 2. var 키워드를 사용하지 않은 변수에 할당하면 삭제할 수 있다
  // 3. var 키워드를 사용해야 하는 또 하나의 목적이다

  console.log(delete sports);

  /*
      var 키워드를 사용하여 선언했다면 비록 이것이 object라도 삭제할 수 없다

      따라서 var 키워드를 사용해서 선언해야 delete 연산자를 사용해도 삭제되지 않는다

      그런데 ES5에서는 삭제불가를 설정할 수 있다.
  */

  debugger;

  console.log('--- 인덱스로 삭제 ---');

  var value3 = [1, 2, 3, 4];
  // 1. 1번 인덱스가 존재하므로 삭제되며 true 반환
  console.log(delete value3[1]);
  // 2. 삭제하였으므로 length가 4에서 3으로 줄어야하는데 변하지 않고 4가출력
  console.log(value3.length);
  // 3. 이것은 배열 처리 매커니즘 때문이다. 다음페이지에서 보자

  debugger;

  /*
          ===== 배열 엘리먼트 삭제 메커니즘 =====

      - 삭제된 인덱스에 undefined 설정
      ---> 배열을 읽을 때 제외시켜야 한다.
  
  */

  console.log('--- 배열 삭제 메커니즘 ---')

  var value4 = [1,2,3,4];
  delete value4[1];
  // 1. 삭제한 인덱스에 undefined가 설정된다.
  console.log(value4);

  for (var k = 0; k < value4.length; k++) {
    console.log(value4[k]);
  }
  // 2. 앞으로 하나씩 당겨서 엘리먼트를 이동하면 처리 시간이 걸리기 때문이다.

  /*
      왜 바로 삭제하지 않고 undefined를 설정하느냐 하는 것.
      시멘틱 그대로 삭제를 시키면 심플한데 왜 undefined를 설정하는가
      
      배열을 처리하는 알고리즘이 옛날에는 좋지않았다.
      예를 들어 배열안에 작성하는 엘리먼트수가 42억개정도 되었을때

      여기서 하나를 지우면 앞으로 한칸식 당겨진다. 옛날에는 사양상에서는
      42억개를 앞으로 당기는것이 부담이 되었기 때문이다.

      컴퓨터가 따라가지를 못했다.
      이럴때는 어떻게 해야하는가? undefined를 제외하는 처리를 해야한다

      이러한 처리를 안에서 해야한다. 하지만 현재는 이것을 들어낼 수가 있다.
      (메소드를 사용해서)

      그러면 이제는 undefined를 제외하는 코드를 짤 필요가 없는 것이다.

      현재는 메소드를 사용해서 제거하고 한칸씩 당겨도 부담이 되지않는다
  
  */
  debugger;
}



