/**
  * 프로그램 설명문서 주석
  * 2021.02 02 수업
  * 
  *         ===== new Array() =====
  * 
  *         - Array 인스턴스 생성, 반환
  * 
  *         - 배열 생성 기준
  *         --> 파라미터에 따라 배열 생성 기준이 다름
  * 
  *         --> 파라미터를 작성하지 않으면 빈 배열
  * 
  *         --> 작성한 순서로 엘리먼트에 설정
  * 
  *         --> new Array(3)처럼 파라미터에
  *             숫자를 작성하면 3개의 엘리먼트 생성
  * 
  *       -----------------------------------------
  *   
  *       -- 배열 생성기준 : Array 오브젝트, 또는 Array 인스턴스 생성 기준
 */
console.log("=====================================");

window.onload = function() {
  "use strict"
  debugger;
  
  var obj = new Array();
  // 1. new Array()로 생성한
  //    인스턴스 타입은 object
  
  console.log(typeof obj);
  console.log(obj.length);
  // 2. length는 배열의 엘리먼트 수를 나타내며
  //    엘리먼트가 없으므로 0 출력
  
  debugger;

  console.log('--- 값 작성 사례 ---')
  var one = new Array(10, 20);
  // 1. 값을 콤마로 다수 작성.
  //    작성한 순서대로 엘리먼트 값으로 설정.
  console.log(one);
  var two = new Array([30, 40]);
  // 2. 배열로 작성하면 1차원을 더한 차원이 된다.
  console.log(two);

  debugger;

  console.log('--- 숫자 하나 작성 ---');

  obj = new Array(3);
  // 1. 숫자 하나를 작성하면 엘리먼트 수가 되어
  //    3개의 엘리먼트를 가진 배열이 된다
  console.log(obj);
  // 2. 엘리먼트에는 undefined가 설정된다
  //    결과 : [undefined,undefined,undefined]
  //    값은 undefined


  /*
      - 한번 생각해 볼것이 있다.

      - new Array를 하면서 10,20같은 형태로 만드는 것이 있는가 하면
        숫자를 사용해서 배열을 만드는 이유는 무엇인가

      - 배열에 엘리먼트를 하나도 작성하지 않았다
        그 후 몇개의 코드를 처리한 다음 1,2,3을 넣었다.
        그러면 처음의 배열에 값이 1,2,3으로 변한다

        그런데 시스템적인 측면에서 생각해봐야한다

      - 배열을 만들면 메모리의 어딘가에 저장이 된다
        그것의 이름을 예를들면 obj로 했었던 것이다

        그 address를, 주소를 obj로 사용하는 것이다

      - 그런데 이때는 element가 없었다. 그리고 난 다음에 다음 코드를 하게
        되면 그 뒤에가서 붙이게 된다. 그럼 이메모리 주소가 100번이라고 했을때

        다음에 붙인것들이 1000번까지 붙여졌다 치자. 그럼 그다음에 1,2,3을 넣으면
        그것이 메모리 주소가 1001번부터라고 가정을 한다. 앞의 배열과 연결된 어떤 뭔가를
        알고 있어야 나중에 이것을 for문을 돌렸을때 순서대로 읽을수가있다.

        이러한 것들이 계속 체인개념으로 연결되어있으면 처리할때 부담이 된다.

        하나로 연결되어 있으면 통채로 읽으면 되는데 산발적으로 흩어져있으면 쫒아다니면서
        걷어와야할 것 아닌가

        이러한 개념이다. 바로이개념이 그개념이다

        처음에 비록 내용은 하나도 없다고 하더라도 자리를 잡아 놓는 것이다.
        3을 작성했다는 애기는 element를 3개이내에서 사용하겠다는 의미가 강한 것이다.

      - 그러나 new Array(10,20) 이것은 앞으로 어떻게 될지 모른다는 뉘앙스가 담겨있다.
        왜냐면 앞으로 어떻게 될지 알고있다면 new Array(3)과 같이 작성하고 값을 인덱스로
        작성해서 집어넣으면 산발적으로 여기저기 퍼져있는, 그런모습은 안될것이다.

      ------------------------------------------------------------------------------

      - ES6에가면 type the Array라는 것이 있다. 그것은 new Array(3)과 같은 개념을 적용했다.
      - new Array(10,20) 이런 개념이 없다
   */

  debugger;
  /*
            ===== Array() =====

        - Array 인스턴스 생성, 반환
        --> new Array()와 생성 방법 및 기능 같음

        - 인스턴스 생성 논리

        --> new Array()는 new 연산자에서
            생성자 함수를 호출하여 인스턴스 생성
        
        --> Array()는 직접 생성자 함수를
            호출하여 인스턴스 생성
  
        -----------------------------------------

        -- new Array 와 Array의 차이점을 간단하게 되집어 보면
           new 연산자로 Array 함수를 호출하면 인스턴스를 생성한다

           이때 프로토타입에 연결되어 있는 constructor가 호출된다
           constructor가 인스턴스를 생성하여 반환한다

        -- 반면 Array 함수는 곧바로 이 constructor 함수를 호출한다.
           그래서 Array 이것은 생성자 함수라고 부를 수 있는데 
           여기서 new 연산자를 사용하지 않았으니깐 함수라고 부른것이다

           그러나 앞이 대문자이다 이것을 보면 이것은 생성자함수라고 볼수있다
           일반적으로 소문자면 메소드나 함수인데 대문자니깐 생성자 함수구나

           그런데 new 연산자를 사용하지 않았구나 라는것
  */

  debugger;

  /*
          ===== length 프로퍼티 =====

      - 배열 [1,2,3]에서
      --> length 값은 3
      --> Array 오브젝트에 {length :3}형태로 작성
      --> 처음 인덱스는0 ,마지막 인덱스는 2

      - 열거/삭제는 할 수 없지만, 변경은 가능

      - length 값을 변경하면 배열의 엘리먼트 수가 변경됨
  */

  var value = [1,2,3]; // 배열 오브젝트
  // 1. {1,2,3}의 length 값은 3

  console.log(value.length);
  // 2. {length : 3} 형태로 설정되므로
  //    length를 프로퍼티 이름으로 악세스 할 수있음

 debugger;

  console.log('--- length 값을 크게 변경 ---');
  
  value.length = 5;
  // 1. 늘어난 엘리먼트 값은 undefined;
  console.log(value);
  // 값은 [1,2,3,undefined,undefined]
  // 즉, 배열인 늘어난 것
  
  console.log('--- length 값을 작게 변경 ---');

  value.length =2;
  // 1. 3에서 2로 줄이면 뒤의 엘리먼트가 삭제된다

  // 이것은 가독성이 떨어지므로 메소드로 처리하는 것이 더낫다
  console.log(value);

 debugger;
}



