/**
  * 프로그램 설명문서 주석
  * 2021.02 14 수업
  * 
  * 
  *           =======================
  * 
  *           @지금부터 다루는 7개 메소드는
  *           모두 콜백 함수를 호출한다
  *           키워드는 ""시맨틱과 독립성""이다
  *     
  *           ========================
  *         
  *           ---> 이것에 주안점을 두고 강좌를 들으면 조금 더 깊게 이해 할 수 있다.
  * 
  * 
 */
console.log("=====================================");

window.onload = function() {
  "use strict"

  /*
            ===== forEach() =====

            - 구분                  - 데이터(값)

            - data                  - 반복 대상
            - 파라미터               - 콜백 함수
                                    - this로 참조할 오브젝트 opt
            - 반환                   - undefined

        
        ----------------------------------------------------

        - 배열의 엘리먼트를 하나씩 읽어 가면서 콜백 함수 호출
        
        - 콜백 함수 파라미터
        ----> 엘리먼트 값, 인덱스, 배열 전체

        - break, continue 사용 불가
        ----> throw는 사용 가능

        - 콜백 함수 분리(독립성)

        - this로 오브젝트 참조
  */

    var list = [ "A" , "B" , "C" ];

    list.forEach(function( el , index, all ){
      console.log( el + ":" + index + ":" + all )
    });
    // 1. 배열의 첫 번째 엘리먼트인 "A"를 읽고
    // 2. 콜백 함수를 호출하면서 파라미터에
    //    엘리먼트 값, 인덱스, 배열 전체를 순서로 설정
    // 3. 콜백 함수의 함수 코드를 실행
    //    console.log() 실행
    // 4. 다음 엘리먼트를 읽는다
    // 5. 2번에서 4번을 배열 끝까지 반복한다

    /*
        콜백 함수 실행이 끝나면 다시 forEach메소드가 콜백함수를 실행하게 된다

        forEach는 "배열의 엘리먼트 수" 만큼 콜백 함수를 호출 한다.

        그리고 호출 할때 마다 "엘리먼트 값, 인덱스, 배열 전체"의 값을 콜백 함수의

        파라미터로 넘겨준다

        ---------------------------------------------------------------------

        7개의 메소드가 다 이와같은 형태로 콜백 함수를 호출한다.

        그런데 콜백함수에는 break와 continue를 사용할 수 없다.

        따라서 처음부터 끝까지 다 반복을 하게 된다.

        이것이 forEach의 특성이며 시멘틱이다.

        즉, forEach는 이러한 의미를 가지고 있는 것이다. 무조건적으로 처음부터 돈다. 
        
        끝까지, 도중에 빠져나갈 수도 없고 continue로 해서 for문의 continue개념으로

        처리할 수도 없다. 라는 것

        그러나 throw문은 사용 할 수 있다.
    */

    debugger;

    console.log('--- 콜백 함수 분리 ---')

    list = [ "A" , "B" , "C" ]

    var fn = function( el , index , all) {
      console.log( el + ":" + index + ":" + all)
    };

    // 1. 코드 1과 같다
    // 2. 단지, 콜백 함수를 분리한 것 뿐이다.

    list.forEach(fn);


    /*
          콜백 함수를 떼어내서 fn이라는 이름을 가진 별도의 함수를 만들었다.

          그리고 앞에서와 같이 list 배열 오브젝트의 forEach메소드를 호출하면서

          파라미터에 콜백함수 이름을 작성했다.

          ----------------------------------------------------------------

          === **여기에 소괄호가 있지 않다** 함수를 호출한것이 아니라 이름을 작성한다

              왜냐하면 forEach 메소드에 함수를 호출하는기능을 가지고 있기 때문에 그렇다

          --------------------------------------------------------------------

          즉, 함수이름을 작성하면 그함수를 forEach에서 호출하는 것이다.

          ----------------------------------------------------------------

          코드 중복을 피하기 위해서 아래처럼 콜백함수를 별도로 떼어 둘 수 있다.

          아래 식에서 forEach메소드는 반복을 하게 되는거고 안의 콜백함수의 코드가

          어떻게 되든지 관여할 바가 아니다.

          === 바로 '콜백함수의 독립성'인 것이다.

          독립적으로 움직이는 것이다
    */

    debugger;


    console.log('--- this로 오브젝트 참조 ---')

    list = [ 1 , 2 ];
    fn = function( el , index , all ){
      console.log( el + this.ten);
    };
    // 1. this로 오브젝트를 참조한다
    // 2. this.ten의 값은 10이다

    list.forEach( fn , {ten : 10} );
    // 3. 함수 안에서 값(데이터)을 참조하는 방법
    //  - 파라미터, 변수 this로 참조, 함수 호출(반환 값)
    // 4. 콜백 함수의 완전한 독립성을 보장

    /*
          == 두번째 파라미터에 this로 참조할 오브젝트를 작성할 수 있다

          그러나 이것은 선택이다.

          -----------------------------------------------------------

          [1, 2] 로 배열 오브젝트를 만들고 fn에다 콜백 함수를 선언했다

          다음에 배열오브젝트에 forEach메소드를 호출하면서 첫번째 파라미터에 
          
          콜백함수를 작성하고(이름), 그리고 오브젝트 작성
    
          -------------------------------------------------------------

          그러면 { ten: 10 } 이것은 파라미터로 넘겨주지 않는다.

          그런데 콜백함수에서 this로 오브젝트를 참조할 수 있다.

          그러면 this.ten을 하게되면 10이다. 그래서 결과적으로 11과 12가 출력된다

          --------------------------------------------------------------------

          이 콜백함수에서 값 또는 데이터를 얻을 수 있는 방법을 생각해 보겠다

          1. 우선 위와 같이 파라미터로 값을 얻을 수 있다.

          2. 또한 아래에다 변수를 선언해서 얻을 수도 있다.

          3. 그리고 지금 보고 있는 this 이다. 
          
          this로 넘겨준 오브젝트를 참조할 수 있는 것이다.

          4. 그리고 다른 함수를 호출해서 다른함수에서 호출해서 함수에서 호출한 값을 
          
          가지고 무엇인가 처리를 할 수 있는 것이다.

          ======== 따라서 함수에서 구할 수 있는 요건을 다 갖추었다라는것 =======

          만약 this가 빠졌다면 이것은 불완전한 형태가 되었을 것이다.
          그러나 this가 들어가게 되어 완전한 형태로 독립적으로 코드를 만들 수가 있다
    
    */
}



