/**
  * 프로그램 설명문서 주석
  * 2021.02 15 수업
  * 
  *     ===== forEach() =====
  * 
  *     - forEach()를 시작할 때 반복 범위 결정
  * 
  *     - 엘리먼트를 추가하더라도 처리하지 않음
  * 
  *     - 현재 인덱스보다 큰 인덱스의 값을 변경하면 변경된 값을 사용
  *     ----> 현재 인덱스보다 작은 엔덱스의 값을 변경하면 처리하지 않음(당연)
  * 
  *     - 현재 인덱스보다 큰 인덱스의 엘리먼트를 삭제하면 배열에서
  *       삭제되므로 반복에서 제외됨
  *     ----> 추가는 처리하지 않지만, 삭제는 반영됨
  * 
  *     ------------------------------------------------------------
  * 
  *     --> forEach메소드를 시작할때 반복 범위가 결정된다.
  *         즉, 반복하는 횟수가 결정되는 것. 따라서 엘리먼트를 추가하더라도 변경X
 */
console.log("=====================================");

window.onload = function() {
  "use strict"

  console.log('--- 반복 도중에 엘리먼트 추가 ---')
  var list =[ 1, 2, 3 ];

  var fn = function( el , index , all ){
    if (index == 0){
      list.push( "AB" );
    };
    console.log( el );
  };
  list.forEach(fn);

  console.log(list);
  // 1. 배열을 "처음 읽었을 때"
  //    즉, index가 0일 때,
  //    배열 끝에 "AB"를 첨부한다
  // 2. 이렇게 반복하는 도중에
  //    배열에 엘리먼트를 추가하면 처리하지 않는다.

  debugger;

  console.log(' --- 큰 인덱스의 값으로 변경 ---')
  list = [ 1, 2, 3 ];
  fn = function( el , index , all ) {
    if ( index == 0 ) {
      list[2] = 345;
      // 1. index가 0일 때 2번 인덱스의 값을 345로 변경
    };
    console.log( el );
  };
  list.forEach( fn );
  // 2. 변경된 값을 사용한다.

  /*
      인덱스에 있는 값보다 큰 값이 들어오면 변경된다.

      그러나 현재 인덱스보다 작은 인덱스가 들어오면 변경하지 않는다
  */

  debugger;

  console.log(' --- 큰 인덱스의 엘리먼트 삭제 ---');

  list = [ 1, 2, 3 ];
  fn = function( el , index , all ){
    if ( index === 0 ) {
      delete list[2];
    };
    console.log( el );
  };
  list.forEach( fn );

  /*
      들어올 당시 현재 인덱스보다 큰 인덱스를 삭제하면 배열에서 삭제되므로
      
      반복에서 제외 된다.
  */

  debugger;

  /*
        ===== for()와 forEach() =====
  
      - forEach()는 시멘틱 접근
      --> 처음부터 끝까지 반복한다는 시멘틱
      --> 반복 중간에 끝나지 않는다는 시멘틱
      --> 시멘틱으로 소스 코드의 가독성 향상

      - for()는 함수 코드를 읽어야 알 수 있음
      --> break, continue

      - forEach()는 반복만 하며
      --> 콜백 함수에서 기능 처리, this 사용 가능

      - forEach()는 인덱스 0부터 시작
      --> for()와 같이 인덱스 증가 값을 조정할 수 없음
      --> 뒤에서 앞으로 읽을 수도 없음, 이것도 시멘틱적 접근

      ---------------------------------------------------

      시멘틱적인 접근은 정해져 있어서 그것만 보면 딱 알수 있는 것을 가르킨다

      (--> 콜백 함수에서 기능 처리, this 사용 가능) 이것 자체가 또 시멘틱인 것이다

      이런 것들이 이미 결정되어 있다. 따라서 forEach메소드만 보면 조건들이 이미 
      
      결정되어 있으니 딱 알수 있는 것이다
  */

  /*
      === 프로그램은 코드가 아닌 시나리오로 푼다 ===

      - 시나리오.
  */

}



