/**
 * 프로그램 설명문서 주석
 * 2022.01.03 수업
 *
 *           ===== get() =====
 *
 *     -----------------------------------------------------------
 *     - 구분                - 데이터(값)
 *     - 형태                - WeakMap.prototype.get()
 *     - 파라미터             - key, 오브젝트
 *     - 반환                - 엘리먼트 value
 *     -----------------------------------------------------------
 *
 *     - WeakMap 인스턴스에서
 *     --> key 값이 같은 value 반환
 *     --> 존재하지 않으면 undefined 반환
 */

console.log("====================================");
"use strict"
// console.log 사용
const {log} = window.console;
{
    "use strict"
    log('------------ get() ---------------');
    const fn = () => {};
    const obj = new WeakMap([
        [fn , "함수"]
    ]);

    log(obj.get(fn));
    // :: "함수"
    debugger;
}
/**
 *           ===== set() =====
 *
 *     -----------------------------------------------------------
 *     - 구분                - 데이터(값)
 *     - 형태                - WeakMap.prototype.set()
 *     - 파라미터             - key, 오브젝트
 *                          - value, 임의의 값
 *     - 반환                - key, value 가 설정된 인스턴스
 *     -----------------------------------------------------------
 *
 *     - WeakMap 인스턴스에 key, value 설정
 *
 *     - 첫 번째 파라미터에 key 로 사용할 오브젝트 작성
 *     --> string 과 같은 프리미티브 값 사용 불가
 *
 *     - 두 번째 파라미터는 값
 *     --> 첫 번째 파라미터의 오브젝트에 대한 값인가?
 *
 *     ----> 첫번째 오브젝트에 대한 값이 아니고,
 *           WeakMap, Map 이 entry 형태이기 때문에
 *           WeakMap entry 의 값이다.
 *           ( 다음장에서 다루는 Set, WeakSet 에서는 key 만 사용 )
 *
 *     --> 오브젝트 구분 등의 용도
 *         오브젝트에 따라 연동하는 함수 등록 가능
 *     ----> 이것은 개발자에게 일임되는 형태
 *           ( 오브젝트에 대한 설명으로도 활용 가능 )
 */
{
    "use strict"
    log('------------ set() ---------------');
    const fn = function(){};
    const obj = new WeakMap([
        [fn , "함수"]
    ]);
    log(obj.get(fn));
    // :: "함수"
    debugger;

    /**
     *  function(){} 이 저장된 메모리 주소가 같다
     */
    obj.set(fn, "함수 변경");
    log(obj.get(fn));
    // :: "함수 변경"
    debugger;

    // 1. obj.set(fn, "함수 변경");

    // 2. fn 의 메모리 주소가 key로 등록되어 있으며
    //    같은메모리 주소로 값을 설정하므로

    // 3. [fn, "함수"] 에서 "함수"가
    //    "함수 변경"으로 변경된다.
}
/**
 *           ===== has() =====
 *
 *     -----------------------------------------------------------
 *     - 구분                - 데이터(값)
 *     - 형태                - WeakMap.prototype.has()
 *     - 파라미터             - key, 오브젝트
 *     - 반환                - 존재하면 true, 아니면 false
 *     -----------------------------------------------------------
 *
 *     - WeakMap 인스턴스에서
 *     --> key 의 존재 여부 반환
 *     --> 존재하면 true, 아니면 false 반환
 */
{
    "use strict"
    log('------------ has() ---------------');
    const obj = {};
    const weakObj = new WeakMap([
        [obj, "오브젝트"]
    ]);
    log(weakObj.has(obj));
    // :: true
    debugger;
}
/**
 *           ===== delete() =====
 *
 *     -----------------------------------------------------------
 *     - 구분                - 데이터(값)
 *     - 형태                - WeakMap.prototype.delete()
 *     - 파라미터             - key, 오브젝트
 *     - 반환                - 삭제 성공 true, 실패 false
 *     -----------------------------------------------------------
 *
 *     - WeakMap 인스턴스에서
 *     --> key 와 일치하는 entry 삭제
 *     --> 삭제를 성공하면 true 반환
 *     --> 삭제를 실패하면 false 반환
 */
{
    "use strict"
    log('------------ delete() ---------------');
    const fn = function(){};
    const obj = new WeakMap([
        [fn , "함수"]
    ]);
    log(obj.delete(fn));
    // :: true
    log(obj.has(fn));
    // :: false
    debugger;
}

/**
 *      - 이처럼 WeakMap 오브젝트 에는 4개의 메소드만 있다
 *      --> 또한, 각 메소드의 공통된 점은 key 를 사용한다라는 것
 *          전체를 열거하거나, 반복하면서 처리하는 것이 없다
 *
 *      --> 오직 key 만 가지고 처리하는 것.
 *          그 키가 object 라는 것이다.
 *
 *      ----> 이런 구조를 갖는 것은 Weak 라는 개념이 강하기 때문이다.
 *
 */





