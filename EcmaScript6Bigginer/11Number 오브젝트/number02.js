/**
 * 프로그램 설명문서 주석
 * 2021.08 31 수업
 *
 *           ===== Number.EPSILON =====
 *
 *      - Number.EPSILOIN
 *      --> 아주 작은 값
 *      --> 2.2204460492503130808472633361816E-16
 *      --> 또는 2**-52(2의-52승)
 *
 *      - 사용 사례
 *      --> 미세한 값 차이 형태
 *      --> 미세한 값 차이를 같은 값으로 간주
 *      --> 0 / 0 으로 NaN가 되는 것을 방지
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const log = window.console.log;
{
    "use strict"
    log('------------ 미세한 값 차이 ---------------');
    const total = 0.1 + 0.2;
    log(total);
    // :: 0.30000000000000004
    log(total === 0.3);
    // :: false
    debugger;

    // 1. 0.1과 0.2를 더했는데
    //    0.3이 아닌 0.30000000000000004를 출력

    // 2. 값이 같지 않으므로 false가 출력된다

    // 3. JS가 부동 소수점 처리를 하기 때문이다
    //    IEEE 754 준수

    // 4. 이처럼 미세한 값 차이로
    //    일치하지 않을 때 EPSILON을 사용한다.
}

{
    "use strict"
    log('------------ 미세한 값차이를 같은 값으로 간주 ---------------');
    const value = Math.abs(0.1 + 0.2 - 0.3);
    // const value = (0.1 + 0.2) ;
    // ::  5.551115123125783e-17
    // --> 이게 존나 작은값이라는 뜻인듯
    log(value);
    log(value < Number.EPSILON);
    // :: true
    debugger;

    // 1. 값 차이가 Number.EPSILON 보다
    //    작으면 true를 반환한다.

    // 위와같이 EPSILON 보다 작을때는 끄트머리 값을 무시하고 0.3으로 간주한다.
}

{
    // 0 나누기 0을하면 Not A Number가 되는데 이것을 방지
    "use strict"
    log('------------ 0 / 0 방지 ---------------');
    log(0 / 0);
    // :: NaN
    const value = 0 / (0 + Number.EPSILON);
    log(value);
    // :: 0
    debugger;

    // 1. 0 / 0은 NaN

    // 2. ( 0 + Number.EPSILON) 처럼
    //    작은 값을 더해 나누면 0이 된다

    // NaN뒤에 값을 더하면 이상한 값이 나오게 되니깐
    //  0 / 0 에다가 EPSILON 값을 더하게 되는 것
    // 그럼으로써 이어지는 연산 처리를 할 수 있다.

    // 3. 0이므로 후속 처리를 할 수 있다.
}

/**
 *           ===== 진수 =====
 *
 *      - Binary(2진수)
 *      --> 0b0101, 0B0101 형태로 작성
 *      --> 숫자 0 다음에 b/B 작성하고
 *          이어서 0 또는 1로 값을 작성
 *
 *      - Octal(8진수)
 *      --> 0O0105 형태로 작성
 *      --> 숫자 0 다음에 영문 o/O 작성하고
 *          이어서 0 ~ 7로 값을 작성
 *
 *      --> ES3는 첫 자리에 영문 o/O 작성
 *      ----> 따라서 ES5에서는 사용을 권장하지 않았다
 *      ----> 그러나 ES6에와서 이렇게 재정의해서 사용할 수 있게 되었다.
 *
 */
{
    "use strict"
    log('------------ Binary(2진수) ---------------');
    const value = 0B111;
    log(value);
    // :: 7
    debugger;

    // 1. 1 + 2 + 4
    //    이것은 뒤에서부터 1 + 2 + 4가되서 7이 나옴
}
{
    "use strict"
    log('------------ Octal(8진수) ---------------');
    const value = 0o111;
    log(value);
    // :: 73

    debugger;
    // 1. 1 + 8 + 64
}



