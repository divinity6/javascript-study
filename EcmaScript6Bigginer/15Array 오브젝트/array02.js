/**
 * 프로그램 설명문서 주석
 * 2021.10.27 수업
 *
 *           ===== copyWithin() =====
 *
 *      -----------------------------------------------------------
 *      - 구분                    - 데이터(값)
 *
 *      - 형태                   - Array.prototype.copyWithin()
 *      - 파라미터                - 복사한 값을 설정할 시작 인덱스
 *                              - 복사 시작 인덱스 opt
 *                              - 복사 끝 인덱스 opt
 *      - 반환                   - 변경된 Array 오브젝트
 *      -----------------------------------------------------------
 *
 *      - 범위 값을 복사하여 같은 오브젝트에 설정
 *        (첫 번째 오브젝트에도 복사하여 설정함)
 *
 *      - 두 번째 파라미터의 인덱스 부터 복사하여
 *      --> 첫 번째 파라미터의 인덱스부터
 *          순서대로 설정(대체)
 *
 *      - 세 번째 파라미터의 인덱스 직전까지 복사
 *
 *      - 복사 시작 인덱스와 끝 인덱스를
 *        작성하지 않으면 배열 전체 복사
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const {log} = window.console;

{
    "use strict"
    log('------------ 3번째 파라미터를 작성하지 않음 ---------------');
    const list = ["A", "B", "C", "D", "E"];
    const copy = list.copyWithin(1, 3);

    log(list);
    // ::  ['A', 'D', 'E', 'D', 'E']
    log(copy);
    // ::  ['A', 'D', 'E', 'D', 'E']

    debugger;
    // 1. list 배열이 대상이다

    // 2. 두 번째 파라미터의 3번 인덱스부터 배열의 끝까지 복사하여

    // 3. 첫 번째 파라미터의 1번 인덱스부터 차례로 설정

    // 4. D와 E를 복사하므로 엘리먼트가 2개이며

    // 5. 1번 인덱스부터 2개를 대체하므로 B가 D로, C가 E로 대체된다

    // 6. 복사 대상에 대체하므로 반환된 Array 오브젝트와 복사 대상이 같다.
}

{
    "use strict"
    log('------------ 3번째 파라미터 작성 ---------------');
    const list = ["A", "B", "C", "D", "E"];
    list.copyWithin(0, 2, 4);
    log(list);
    // :: ['C' , 'D' , 'C' , 'D' , 'E'];
    // A,B가 C,D로 변경됨
    debugger;

    // 1. 두 번째 파라미터의 2번 인덱스부터

    // 2. 세 번째 파라미터의 4번 인덱스 직전까지
    //    복사하여 list 배열의 0번 인덱스부터 설정

    // 3. 2번 인덱스, 3번 인덱스를 복사하므로
    //    C와 D를 복사하게 된다

    // 4. A가 C로, B가 D로 대체된다.
}
{
    "use strict"
    log('------------ 2번째, 3번째 파라미터 작성하지 않음 ---------------');
    const list = ["A", "B", "C", "D", "E"];
    list.copyWithin(3);
    log(list);
    // :: ['A' , 'B' , 'C' , 'A' , 'B' ];
    debugger;

    // 1. list 배열 전체가 복사 대상이다

    // 2. 3번 인덱스부터 대체한다

    // 3. 복사할 엘리먼트 수가
    //    대체할 엘리먼트 수보다 많으면

    // 4. 매체되는 인덱스만 값을 대체하고
    //    남는 것은 대체하지 않는다

    // 5. D가 A로, E가 A로 대체된다.
}

/**
 *           ===== copyWithin() =====
 *
 *      - copyWithin() 함수의 특징
 *      --> shallow copy(얕은 복사)
 *      --> 같은 배열 안에서 이동하는 개념
 *          ( 즉, 배열을 새로만드는게 아니라 같은 배열안에서 이동하는 개념 )
 *      --> 배열의 엘리먼트 수가 변동되지 않음
 *
 *      - 배열 안에서 엘리먼트를 이동은
 *      --> 엘리먼트를 왼쪽, 오른쪽으로 이동하는 것
 *      --> 처리 속도가 빠름
 */
{
    "use strict"
    log('------------ 특징 ---------------');
    const list = ['A', {B: "가"}, 'C'];
    log(list.copyWithin(0, 1));
    // :: [{B: "가"}, 'C' , 'C'];
    debugger;

    // 1. {B:"가"}를 복사할 때 새로운 {B:"가"}를 만들지 않고
    //    현재의 메모리 주소를 복사한다

    // 2. shallow copy(얕은 복사)라고 한다
    //    (메모리 주소를 복사하니깐, 값이 연동된다.)

    // 3. shallow copy는 값이 연동된다

    // 4. 연동되지 않도록 하려면 Deep Copy를 해야 한다.
    //    (Deep Copy는 프로퍼티 단위로 복사를 하게 된다.)
    /**
     *  - shallow copy는 메모리 주소를 복사하기 때문에
     *    처리 속도가 빠르다.
     */
}