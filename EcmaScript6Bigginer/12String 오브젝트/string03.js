/**
 * 프로그램 설명문서 주석
 * 2021.09 08~09 수업
 *
 *           ===== startsWith() =====
 *      -----------------------------------------------------------
 *      - 구분                   - 데이터(값)
 *
 *      - 형태                   - String.prototype.startsWith()
 *      - 파라미터                - 비교 문자열
 *                              - 비교 시작 인덱스(opt) 디폴트: 0
 *      - 반환                   - 시작하면 true, 아니면 false
 *      -----------------------------------------------------------
 *
 *      - 대상 문자열이
 *      --> 첫 번째 파라미터의 문자열로
 *          시작하면 true, 아니면 false 반환
 *
 *      --> 정규 표현식 사용 불가
 *
 *      - 두 번째 파라미터
 *      --> 선택이며, 비교 시작 인덱스 작성
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const {log} = window.console;

{
    "use strict"
    log('------------ startsWith() ---------------');
    const target = "ABC";
    log(target.startsWith("AB"));
    // :: true

    // "BC"가 target 변수에 있긴 있지만 첫번째가 아니다. 따라서, false
    log(target.startsWith("BC"));
    // :: false

    // 이것들은 정규표현식의^과 같다.
    log(/^AB/.test(target));
    // :: true

    debugger;

    // 1. "AB"로 시작하므로 true를 반환한다

    // 2. "BC"가 있지만 시작이 아니므로 false

    // 3. 정규 표현식의 ^과 같다

    /**
     * startsWith 메소드에는 정규 표현식을 사용할 수 없다.
     */
}
{
    "use strict"
    log('------------ 시작 인덱스 작성 ---------------');
    const target = "ABCD";

    // 비교값, 인덱스
    log(target.startsWith("BC", 1));
    log(target.startsWith("BC", 2));
    debugger;

    // 1. "BC"가 중간에 있지만

    // 2. 시작 인덱스가 1이므로 true를 반환한다.
}

/**
 *      - 앞의 startsWith와 반대. 이것은 end
 *
 *           ===== endsWith() =====
 *      -----------------------------------------------------------
 *      - 구분                   - 데이터(값)
 *
 *      - 형태                   - String.prototype.endsWith()
 *      - 파라미터                - 비교 문자열
 *                              - 사용할 문자열 길이(opt) 디폴트: 문자열 전체
 *      - 반환                   - 끝나면 true, 아니면 false
 *      -----------------------------------------------------------
 *
 *      - 대상 문자열이
 *      --> 첫 번째 파라미터의 문자열로
 *          끝나면 true, 아니면 false 반환
 *
 *      - 두 번째 파라미터
 *      --> 선택이며, 사용할 문자열 길이 지정(비교할 문자열 길이)
 *
 */
{
    "use strict"
    log('------------ endsWith() ---------------');

    const target = "ABC";

    // 비교할 문자열
    // 두번째 파라미터를 작성하지 않았기에 "ABC"가 비교 대상이 된다.
    log(target.endsWith("BC"));
    // :: true

    // "AB"가 있긴있지만 다음에 C가 있다. 즉, AB로 끝나는게 아니다.
    log(target.endsWith("AB"));
    // :: false

    // 정규식은 이와같다.
    // $패턴은 뒤에서 부터 앞으로 비교하는 것.
    // 즉 맨뒤에서부터 C가있고 B가 있어야한다.
    log(/BC$/.test(target));
    // :: true

    debugger;

    // 1. "BC"로 끝나므로 true를 반환한다

    // 2. "AB"가 있지만 끝이 아니므로 false

    // 3. 정규 표현식의 $와 같다.
}
{
    "use strict"
    log('------------ 사용할 문자열 지정 ---------------');

    // 아 앞에서부터 비교할 문자열 길이를 정하는건가부다
    // index가 아니다.
    const target = "ABC";
    log(target.endsWith("AB", 2));
    // :: true

    debugger;

    // 1. "AB"로 끝나지 않지만

    // 2. 대상 문자열을 3자리가 아닌
    //    2자리를 사용하므로
    //    즉, "AB"만 사용하므로 true를 반환한다.

    /**
     *  - 2번째 파라미터에 2를 작성하면, C는 날아가게되고 문자열 AB를 비교
     *    /BC$/ 이 정규표현식과 다른점은 정규표현식을 이런식으로 몇번째처럼
     *    처리하려면 BC$에다 또다른 패턴을 줘야한다.
     *    ( 복잡해 진다. )
     */

}
/**
 *
 *           ===== repeat() =====
 *      -----------------------------------------------------------
 *      - 구분                   - 데이터(값)
 *
 *      - 형태                   - String.prototype.repeat()
 *      - 파라미터                - 복제할 수(opt) 디폴트 : 0
 *      - 반환                   - 복제하여 만든 문자열
 *      -----------------------------------------------------------
 *
 *      - 대상 문자열을
 *      --> 파라미터에 작성한 수만큼
 *          복제하고 연결하여 반환
 *
 */
{
    "use strict"
    log('------------ repeat() ---------------');
    const target = "ABC";
    log(target.repeat(3));
    // :: ABCABCABC
    log(target.repeat(0));
    // :: ""

    // 디폴트가 0
    log(target.repeat());
    // :: ""
    log(target.repeat(2.7));
    // :: ABCABC

    debugger;

    // 1. repeat(3)
    //    "ABC"를 3번 복제하고 연결하여 반환

    // 2. 파라미터를 작성하지 않거나 0을 작성하면 빈문자열을 반환

    // 3. 2.7에서 0.7을 무시하고 2를 사용
}
/**
 *      -- 이것은 편리한 만큼 많이 사용한다 --
 *
 *           ===== includes() =====
 *      -----------------------------------------------------------
 *      - 구분                   - 데이터(값)
 *
 *      - 형태                   - String.prototype.includes()
 *      - 파라미터                - 존재 여부 비교 문자열
 *                                 비교 시작 인덱스(opt) 디폴트 : 0
 *      - 반환                   -  존재하면 ture, 아니면 false
 *      -----------------------------------------------------------
 *
 *      - 대상 문자열dp
 *      --> 첫 번째 파라미터의 문자열이 있으면 true
 *          없으면 false 반환
 *
 *      - 첫 번째 파라미터
 *      --> 숫자이면 문자열로 변환하여 체크
 *
 *      - 두 번째 파라미터(선택)
 *      --> 비교 시작 인덱스 작성
 *      
 *      - 정규 표현식 사용 불가
 *
 */
{
    "use strict"
    log('------------ includes() ---------------');
    const target = "123";
    log(target.includes("1"));
    // :: true

    // 숫자를 문자로 변환하여 비교하네
    log(target.includes(12));
    // :: true

    log(target.includes("13"));
    // :: false
    debugger;

    // 1. "1"과 12는 존재하며
    // 2. "13"은 존재하지 않는다.

    /**
     *  - 숫자를 문자로 변환하여 체크하는 이유는
     *    includes가 String 오브젝트에 속한다.
     *    따라서, 대상도 문자열이 되어야 한다.
     *
     *  - 그렇기 때문에 숫자가 들어오면 문자열로
     *    변환하여 비교를 하게 된다.
     */
}

{
    "use strict"
    log('------------ 시작 인덱스 작성 ---------------');
    const target = "ABC";
    log(target.includes("A", 1));
    // :: false

    try {
        result = target.includes(/^A/);
    } catch (e) {
        log("정규 표현식 사용 불가");
    }
    // :: 정규 표현식 사용 불가

    debugger;

    // 1. "A"가 있지만 0번 인덱스에 있다

    // 2. 1번 인덱스부터 비교하므로 존재하지 않는다.
}



/**
 *
 *           ===== row =====
 *
 *      - Template 개념의 이해가 필요하므로
 *      --> Template에서 같이 다룬다.
 */















