/**
 * 프로그램 설명문서 주석
 * 2021.08 08 수업
 *
 *
 *           ===== 이터레이션 =====
 *
 *      - 과정 중간에 이터레이션 개념 이해가 필요하므로
 *      --> 먼저 다루며
 *      --> 이 장에서는 이터레이션 개념만 다루고
 *      --> 자세한 것은 Symbol 오브젝트에서 다룬다.
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const log = window.console.log;

/**
 *           ===== 이터레이션 =====
 *
 *      - 이터레이션(Iteration)의 사전적 의미 : 반복
 *      --> for()문의 반복 개념과 차이 있음
 *      ----> for문의 반복과 이터레이션의 반복은 차이가 있다.
 *      --> 강좌에서는 이터레이션과 반복을 같이 사용
 *
 *      - 이터레이션을 위한 프로토콜(protocol) 필요
 *      --> 예 : 통신 프로토콜(규약)
 *      --> [[이것은 데이터 송수신을 위한 프로토콜, 즉 규약을 정의해 놓은 것.]]
 *          ( 데이터가 이규약에 맞춰서 통신을 하게 되는 것 )
 *
 *      ----> 마찬가지로 이터레이션을 하려면 프로토콜이 있어야 한다.
 *            ( 어떻게 이터레이션, 반복을 할 것인가? 라는 것. )
 *
 *      - 즉, 이터레이션은 프로토콜을 갖고 있으며
 *      --> 프로토콜에 따라 이터레이션 수행
 *      ----> 예) 아래의 obj.next()도 하나의 프로토콜인 것이다.
 *                [Symbol.iterator]()도 하나의 프로토콜,
 *
 *      ------> iterator 함수를 호출하면, 무엇이 어떻게 나온다!
 *              라는 규약!!
 *
 *      ------> 그리고, next를 호출하면 어떻게 한다! 라는 규약!
 *
 *
 *      --> 프로토콜이 구문과 빌트인이 아니므로
 *          프로토콜에 맞으면 이터레이션 가능
 *
 *      ----> 그렇다고 프로토콜이 구문과 빌트인은 아니다.
 *            프로토콜이기 때문. 그래서 이 프로토콜에 맞으면
 *            이터레이션이 가능하다라는 것.
 *
 *      ------> 즉, 개발자가 프로토콜에 맞추면 이터레이션을 할 수있다라는 것.
 *              (확장성이 있다라는 것)
 *
 */

log('------------이터레이션---------------');
"use strict";
const list = [10, 20];

for (let value of list) {
    debugger;
    log(value);
    // :: 10
    // :: 20
}

const obj = list[Symbol.iterator]();
log(obj.next());
// :: {value: 10, done: false}
log(obj.next());
// :: {value: 20, done: false}
log(obj.next());
// :: {value: undefined, done: true}

/**
 *           ===== for문과의 차이 =====
 *
 *      - 위의 for of문처럼 반복을 할 수도있다.
 *
 *      --> 그런데, Symbol.iteratior를 호출해서,
 *          하나씩 읽어갈 수 있다.
 *
 *      - for of 문은 한꺼번에 왕창, 10, 20을 계속 반복해서 읽는 것이고,
 *        obj.next()은 step by step이다.
 *
 *      --> next()를 호출하면 10을 읽고, 또 다음의 next()를 호출하면 20을 읽고
 *          이러한 개념이다.
 *
 *      --> 따라서, for문의 반복과는 차이가 있다.
 *
 *      - 즉, [Symbol.iterator]이 더 추가된것.
 *      --> 이것때문에 이터레이션이라는 개념을 쓰는 것
 */

/**
 *           ===== 이터레이션 프로토콜 =====
 *
 *      - 이터레이션 프로토콜(규약)은
 *
 *      - 우선 오브젝트가 이터레이션할 수 있는
 *        (반복할 수 있는) 구조이여야 하며
 *
 *      --> 예) Array의 [10, 20]은 가능,
 *          그러나 Number의 100은 불가능
 *
 *      ----> 따라서 Number의 100은 이터레이션 프로토콜에
 *            맞지 않으니깐, 이터레이션을 할 수 없다.
 *
 *      - 이터레이션 함수를 갖고 있어야 한다.
 *
 *      - 이터레이션 프로토콜 구분
 *      --> 이터러블(iterable) 프로토콜
 *      --> 이터레이터(iterator) 프로토콜
 *
 *      - 개발자 코드로 프로토콜을 맞추면
 *      --> 이터레이션 할 수 없는 오브젝트를
 *          이터레이션할 수 있도록 만들 수 있음.
 *
 */

log('------------이터레이션---------------');

const list2 = [10, 20];
const obj2 = list2[Symbol.iterator]();

log(obj2.next());
// :: {value: 10, done: false}
log(obj2.next());
// :: {value: 20, done: false}
log(obj2.next());
// :: {value: undefined, done: true}
debugger;

/**
 *           ===== 이터레이션 구조 =====
 *
 *      - Array(list2)는 이터레이션을 할 수 있는 구조인 것이다.
 *      --> 그리고, Object에는 Symbol.iterator라는 함수가 있어야한다.
 *
 *      - 즉, Iteration 함수가 있어야 한다.
 *        [Symbol.iterator]이 없으면 이터레이션을 할 수 없기 때문이다.
 *
 *      - 이터레이션 프로토콜은
 *      --> iterable 프로토콜과
 *      --> iterator 프로토콜로 나눌 수 있다.
 *
 *      ----> list2[Symbol.iterator]()까지가 iterable 프로토콜이고,
 *
 *      ----> 이것을 obj2에 할당하고(만들고),
 *            이것을 실행하는, log(obj2.next());
 *            이것을 iterator 프로토콜이라고 한다.
 *
 *      - 개념적으로 이터러블(iterable),과 이터레이터(iterator)는 이렇다
 *
 *      --> 이터러블(iterable) : [10,20] 처럼 반복 가능 해야하고,
 *      --> 이터레이터(iterator) : 반복가능한 오브젝트를 이터레이터 오브젝트로 만드는 프로토콜!
 *
 *
 *           ===== 여기서 생각해야할 것 =====
 *
 *      - 이터러블(iterable) 프로토콜을 정의하고
 *      - 이터레이터(iterator) 프로토콜을 정의하는 이유가 무엇인가?
 *
 *      --> 한마디로 말해서 확장성이다.
 *
 *      ----> 즉,개발자 코드로 프로토콜(규약) 맞추면
 *      ----> 이터레이션 할 수 없는 오브젝트를
 *            이터레이션할 수 있도록 만들 수 있음.
 *
 *      ------> 예) 프로퍼티로 구성된 빌트인 오브젝트는 iterable 오브젝트가 아니다.
 *                  그런데 그것을 맞추면, 이터레이션할 수 있도록 만들 수가 있다라는 것.
 *
 *      ------> 프로토콜이라는 개념에서 이러한 뉘앙스가 풍기는 것.
 *              즉, 규약에 맞추면 이터레이션 할 수 없는 오브젝트도 이터레이션 할 수 있다라는 것.
 *
 *
 *      - 여기에 초점을 맞추고 이터레이션을 이해하면 목적을 향해 갈수 있다.
 */










