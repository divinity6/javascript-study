/**
 * 프로그램 설명문서 주석
 * 2021.10.17 수업
 *
 *           ===== String.raw =====
 *
 *      -----------------------------------------------------------
 *      - 구분                    - 데이터(값)
 *
 *      - 형태                   - String.raw `templateString`
 *      - 반환                   - 반환 형태opt
 *      -----------------------------------------------------------
 *
 *      - String 오브젝트에 속하지만
 *      --> Template을 사용하므로 여기서 다룬다
 *
 *      - String.raw에
 *      --> 이어서 Template 작성
 *      --> 줄 바꿈을 문자로 처리
 *      --> 유니코드의 코드 포인트 처리
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const {log} = window.console;

{
    "use strict"
    log('------------ String.raw ---------------');
    const one = 1, two = 2;

    /**
     *  - String.raw 다음에 Template를 작성한다.
     *  --> 여기까지는 template를 일반함수에 매개변수로 넘겨주는 모습과 같다.
     */
    const result = String.raw`1+2=${one + two}`;
    log(result);
    // :: 1+2=3
    debugger;

    // 1. one에 1을, two에 2를 설정한다

    // 2. 표현식을 평가하고 결과를 표현식 위치에 설정한다

}

{
    "use strict"
    log('------------ 줄 바꿈 ---------------');

    /**
     *  템플릿만 작성하면 줄바꿈을 실행한다.
     */
    log(`one\ntwo`);
    // :: one
    // :: two

    /**
     *  - String.raw 다음에 Template를 작성한다.
     *  --> String.raw는 템플릿 안에 작성한 특수문자를 일반문자로 처리한다
     *  ----> 이것이 String.raw를 작성한 것의 차이이다.
     *
     *  --> 또한, 일반문자로 출력된다.
     */
    log(String.raw`one\ntwo`);
    // :: one\ntwo
    debugger;

    // 1. 역슬래시(\n)를 특수 문자가 아니라
    //    일반 문자로 처리한다

    // 2. \n을 일반 문자로 처리하므로
    //    줄을 바꾸지 않는다.
}

{
    "use strict"
    log('------------ 코드 포인트 ---------------');
    /**
     *  - \u = 유니코드의 코드포인트값을 문자로 출력한다.
     *  --> 1과 2가 {31}과 {32}
     */
    log(`\u{31}\u{32}`);
    // :: 12

    log(String.raw`\u{31}\u{32}`);
    // :: \u{31}\u{32}
    debugger;

    // 1. 역슬래시()에 이어서 유니코드를 작성한다
    //    코드 포인트 값을 문자로 반환한다

    // 2. 역슬래시()를 일반 문자로 처리하므로
    //    유니코드를 변환하지 않고 문자로 출력한다.
}

/**
 *           ===== String.raw() =====
 *
 *      -----------------------------------------------------------
 *      - 구분                    - 데이터(값)
 *
 *      - 형태                   - String.raw()
 *      - 파라미터                - {raw : 값} 형태
 *                              - 조합할 값
 *      - 반환                   - 반환 형태opt
 *      -----------------------------------------------------------
 *
 *      - raw의 "문자열"을 문자 하나씩 전개하면서
 *      --> 두 번째 파라미터부터 조합하고 연결
 *      --> 문자열
 *      --> 배열
 *
 *      - 첫 번째 파라미터는 {raw: 값} 형태
 *
 *      - 두 번째 파라미터부터 조합할 값 작성
 *      --> ({raw: "ABCD"},1,2,3)
 *
 */

{
    "use strict"
    log('------------ 문자열 ---------------');
    const one = 1, two = 2;
    /**
     *  5번째 파라미터는 값자체를 첨부하지 않음
     *
     *  - raw는 다른 이름을 사용할 수 없고 raw를 사용해야 한다.
     *  --> 프로퍼티값에는 배열, 문자열등을 작성할 수 있다.
     *  --> 두 번째 파라미터부터 조합할 값을 작성한다.
     */
    log(String.raw({raw: "ABCD"}, one, two, 3, 5))
    // :: A1B2C3D
    debugger;

    // 1. A를 반환 버퍼에 넣고

    // 2. raw()의 2번째 파라미터 값을 버퍼에 첨부
    //    즉, one 변숫값인 1을 첨부하며 A1이 된다.

    // 3. B를 반환 버퍼 끝에 첨부한다

    // 4. raw()의 3번째 파라미터 값을 버퍼에 첨부
    //    즉, two 변숫값인 2를 첨부한다

    // 5. 현재까지의 모습은 A1B2

    // 6. C를 반환 버퍼 끝에 첨부한다.

    // 7. 4번째 파라미터 값인 3을 버퍼에 첨부

    // 8. D를 반환 버퍼 끝에 첨부한다
    //    5번째 파라미터는 값이 없어서 첨부하지
    //    않는 것이 아니라 값 자체를 첨부하지 않는다
    // -  왜냐하면 D 뒤에는 표현식이 없는 것으로 처리하기 때문이다.

    // 9. 조합한 결과를 반환한다.

    /**
     *  - 즉, 이와같이 raw 프로퍼티 값을 하나씩 분리해서, 파라미터 값을 조합해서
     *    문자열로 만들어 반환한다.
     */
}

{
    "use strict"
    log('------------ 배열 ---------------');
    const rawValue = {raw: ["A", "B", "C"]};
    log(String.raw(rawValue, 1, 2, 3));
    // :: A1B2C
    debugger;

    // 1. `A${1}B${2}C`
    // 2. C 뒤에는 표현식이 없는 것으로 처리한다.
    //    따라서 3이 첨부되지 않는다.

    /**
     *  - C 뒤의 마지막은 빼버린다.
     *  --> C뒤의 표현식은 빼버린다
     *  ----> 이것이 포맷이라는 것이다.
     *  ----> 따라서 3은 조합하지 않는 것이다.
     *  
     *  ===== 위에서 D뒤에 우연히 값이 첨부되지 않는게 아니라
     *    마무리는 문자열로 짓는다는 것(표현식은 첨부하지 않는다! 라는 것!) =====
     */
}