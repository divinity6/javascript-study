/**
 * 프로그램 설명문서 주석
 * 2021.08 17 수업
 *
 *
 *           ===== 분할 할당(destructuring) =====
 *
 *      - Destructuring(파괴) Assignment(할당)
 *
 *      - 작성 형태
 *
 *      - 사전적 의미
 *      --> ~ 구조를 파괴하다 [di : strAktjer]
 *      --> 파괴, 해체는 있는 것이 없어지는 뉘앙스
 *      --> 원 데이터는 변경되지 않음
 *      ----> 사전적 의미와는 조금 차이가 있다.
 *
 *      - 강좌 기준
 *      --> 이 관점에서 보면 분할/분리가 더 가까움
 *      --> 강좌에서는 "분할 할당"으로 표기
 *
 */
console.log("=====================================");
"use strict"
// console.log 사용
const log = window.console.log;
{
    "use strict"
    log('------------ Destructuring ---------------');

    let one, two, three;
    const list = [1, 2, 3];

    // 변수를 한꺼번에 할당할 수 있다.
    // 1, 2, 3을 하나 하나씩 매핑시켜서 할당하는 개념

    // 원래인 list는 사라지지않음
    // (단지 안에있는 것들을 분할해서 one, two, three에 넣어준것 뿐!)
    [one, two, three] = list;

    const arr = [1, 2, 3];
    const [one2, two2, three2] = arr;

    log(one);
    // :: 1
    log(two);
    // :: 2
    log(three);
    // :: 3
    log(list);
    // :: [ 1, 2, 3 ]
    debugger;
}

/**
 *           ===== Array 분할 할당 =====
 *
 *      - 배열의 엘리먼트를 분할하여 할당
 *      --> 인덱스에 해당하는 변수에 할당
 *      --> 할당받을 변수 수가 적은 경우
 *      --> 할당받을 변수 수가 많을 경우
 *      --> 배열 차원에 맞추어 분할 할당
 *      --> 매치되는 인덱스에 변수가 없으면
 *          값을 할당하지 않음
 *
 *      - spread와 같이 사용
 *      --> 나머지를 전부 할당
 *      --> 인덱스를 반영한 나머지 할당
 *
 */

{
    "use strict"
    log('------------ 인덱스 기준으로 할당 ---------------');
    let one, two, three;
    [one, two, three] = [1, 2, 3];
    log(one);
    // :: 1

    log(two);
    // :: 2

    log(three);
    // :: 3
    debugger;

    // 1. 왼쪽의 인덱스에 해당하는
    //    오른쪽 배열의 값을 변수에 할당한다.

    // 2. one에 1, two에 2, three에 3이 할당된다.
}

{
    "use strict"
    log('------------ 할당받을 변수 수가 적은 경우 ---------------');
    let one, two;
    [one, two] = [1, 2, 3];
    log(one);
    // :: 1

    log(two);
    // :: 2
    debugger;

    // 1. 왼쪽에 할당받을 변수가 2개이고
    //    오른쪽에 분할 할당할 값이 3개이다

    // 2. 왼쪽의 변수 인덱스에 맞춰
    //    값을 할당하므로 3은 할당되지 않는다.
    // --> 여기서 기준은 왼쪽 변수 인덱스다.
}

{
    "use strict"
    log('------------ 할당받을 변수 수가 많은 경우 ---------------');
    let one, two, three, four;
    [one, two, three, four] = [1, 2, 3];
    log(three);
    // :: 3

    log(four);
    // :: undefined
    debugger;

    // 1. 왼족의 할당받을 변수가 4개이고
    //    오른쪽에 분할 할당할 값이 3개이다

    // 2. 왼쪽에 값을 할당할 수 없는 변수에
    //    undefined가 설정된다.
}

{
    "use strict"
    log('------------ 배열 차원에 맞추어 분할 할당 ---------------');
    let one, two, three, four;

    // one, two가 1차원배열,
    // three, four가 2차원배열이다.
    // 그런데 데이터도 같은차원으로 맞춰주면

    [one, two, [three, four]] = [1, 2, [3, 4], 5];

    // 차원을 무시하고 1차원 배열로 맞춰준다
    log([one, two, three, four]);
    // :: [ 1, 2, 3, 4]
    debugger;

    // 1. [three , four]와 [3,4]가 배열이다
    // 2. 배열 차원이 변환된다.
}

{
    "use strict"
    log('------------ 인덱스에 변수가 없을 때 ---------------');
    let one, two, three, four;
    [one, , , four] = [1, 2, 3, 4];

    log([one, two, three, four]);
    // :: [1, undefined, undefined, 4]

    debugger;

    // 1. [ one, , , four ] 형태에서
    //    콤마로 구분하고 변수를 작성하지 않았다.

    // 2. 인덱스를 건너 띄어 할당한다.(콤마만 찍으면)

    // 3. one에 1을 할당하고
    //    2와 3은 건너 띄고 four에 4를 할당한다.
}

{
    "use strict"
    log('------------ 나머지를 전부 할당 ---------------');
    let one, rest;
    // rest는 호출받는 함수의 파라미터에 작성하는 형태다.

    // 이와같이 분할하는 것은 spread이다.
    // 그런데 나머지라는 시멘틱이 엄청강한 것이다. 2,3,4나머지를 rest에 할당한다.(시멘틱적으로 접근)
    [one, ...rest] = [1, 2, 3, 4];
    log(one);
    // :: 1
    log(rest);
    // :: [2, 3, 4]
    debugger;

    // 1. one에 1을 할당하고

    // 2. 나머지 2, 3, 4를 rest에 할당한다.
    //    [2, 3, 4]처럼 배열로 할당한다

    // 3. rest 파라미터를 호출받는 함수의 파라미터에
    //    작성하지만, 나머지라는 시멘틱이 강해서
    //    코드처럼 사용하기도 한다.

    // 4. 분리하지 않고 결합된 상태를 설정하므로 어긋나지 않는다.
}

{
    "use strict"
    log('------------ 인덱스를 반영한 나머지 할당 ---------------');
    let one, three, rest;
    [one, , three, ...rest] = [1, 2, 3, 4, 5];
    log(three);
    // :: 3
    log(rest);
    // :: [ 4, 5,]
    debugger;

    // 1. one에 1을 할당한다.
    // 2. 2는 건너뛰고 three에 3을 할당한다.
    // 3. 나머지 [4, 5]를 rest에 할당한다.
}

/**
 *      이와같이 다양한 방법으로 배열을 분할 할당할 수 있다.
 *
 */










