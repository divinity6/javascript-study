/**
 * 프로그램 설명문서 주석
 * 2021.07 27~8 수업
 *
 *           ===== 호이스팅 =====
 *
 *      - ES5의 실행 콘텍스트 처리 순서
 *      1. 함수 선언문 설정
 *      2. 변수 이름을 바인딩
 *         변숫값은 undefined
 *      --> 함수 표현식도 변수를 사용하므로 변수에 해당.
 *      --> 이때, 변숫값은 undefined이다.
 *      --> 함수 표현식도 함수이긴 하지만, 변수이름을 기준으로
 *          바인딩되므로 undefined가 설정된다.
 *
 *      3. 소스 코드 실행
 *
 *      - let 변수는 호이스팅(Hoisting)되지 않음
 *      --> 즉, let 변수 앞에서 변수 사용 불가
 *
 *      - let 변수를 인식하는 시점
 *      - block 안에 let 변수 작성
 */
console.log("=====================================");
"use strict";
// console.log 사용
const log = function (value) {
    console.log('--- ' + value + ' ---');
};

log('호이스팅');
console.log('music 변수: ', music);
// :: music 변수:  undefined
var music = "음악";
// 1. log("music 변수", music);
//    코드 아래에 var music = "음악"이 있다.

// 2. 변수가 아래에 있지만 식별자 해결을 할 수 있다.
//    단, 이 위치에서 music 값은 undefined

// 3. 이것을 호이스팅이라고 한다

// 4. 식별자 해결을 하지못하면 에러가 발생한다.

//    그러나 var 변수는 아래에 작성하더라도 위에서 변수이름을 사용해서 값을 구할 수 있다.
//    음악이 구해지는 것은 아니고 undefined가 구해진다.

log('호이스팅되지 않음');
try {
    // 여기서 에러가 나기 때문에 try문사용
    console.log(sports);
} catch (e) {
    // 에러가 나서 '호이스팅 불가' 출력
    console.log('호이스팅 불가');
}
// :: 호이스팅 불가
let sports = "축구";

/**
 *      - let 변수는 위와같이 let변수가 선언된 위에서, 앞에서 변수 사용 불가
 *      --> 즉, 변수로 인식하지 못한다는 것. 그래서 에러
 */

log('let 변수를 인식하는 시점');
debugger;

// 변수가 모두 아래에 작성되어 있다.
console.log(globalVar);
/**
 *      1. console에 undefined가 출력된다.
 *
 *      2. 오른쪽의 Global(Window)를 펼치면
 *      - globalVar 변숫값이 undefined 이지만
 *      - 변수가 표시된다
 *
 *      3. 반면, globalLet 이름은 표시되지 않는다.
 *      - 변수로 인식하지 않은 것을 뜻한다.
 */

/**
 * 추신 )
 * 강의를 만드는 시점에는 let 변수와 const 변수가 브라우저 디버거 창의 오른쪽 Scope에 표시되지 않았으나,
 * 질문이 있어 체크해 보았더니 표시됩니다. 브라우저 디버거 창의 Scope에 표시하는 기준이 변경되었습니다.
 * 변수가 표시되더라도 변수 앞에서 호이스팅으로 let 변수, const 변수를 사용할 수 없으며 에러가 발생합니다만,
 * 변수를 표시하여 가독성의 편리를 제공하기 위한 것으로 생각됩니다.
 */

debugger;

var globalVar = "var 변수";

/**
 *      1. globalVar 변수에 "var 변수"가 할당된다
 *      - 이때 초깃값인 undefined가 변경된다.
 */
debugger;

try {
    console.log(globalLet);
} catch (e) {
    console.log("globalLet 인식하지 못함");
}
/**
 *      1. 아래의 globalLet을 인식하지 못해 에러가 발생한다.
 */

let globalLet;
/**
 *      1. 비로소 이때 오른쪽 Script에 globalLet이 표시된다
 *      - 즉, 변수 선언을 실행해야 표시된다.
 *
 *      2. 값을 할당하지 않고 변수를 선언만 하면
 *      - 엔진이 undefined를 할당한다.
 *      --> 즉, 변수 선언을 한 후에야 비로소 값을 갖게된다.(undefined)
 */
debugger;
// 찍으면 undefined가 나온다
console.log(globalLet);
/**
 *      1. let 변수는,
 *      - 변수 선언을 실행한 후에 변수를 인식할 수 있다.
 *      - 즉, 식별자를 해결할 수 있다.
 *
 *      --> 자바스크립트는 undefined도 값이다.
 *      --> 따라서, 선언만하게되면 엔진이 undefined를 설정한다.
 *      --> 그래서 변수이름과 값을 가지게 된다.
 *      ----> 비로소 이때!
 */
debugger;

// block 안에 변수 작성
{
    console.log(variable);

    /**
     *      1. 오른쪽의 Global(Window)를 펼치면
     *      - variable의 변숫값이 undefined이지만
     *      - 변수 이름이 표시된다.
     *
     *      2. blockLet 변수도 undefined로 표시된다.
     *      - 하지만, 호이스팅으로 변수를 사용할 수는 없다.
     *
     *      3. 앞에서 글로벌 변수는 Script에
     *      - 변수가 표시되지 않았다.
     *      - block은 이때도 표시가 된다.
     *        (즉, 이안을 엔진이 한번 훑었다는 것. 그래서 blockLet이 있다는 것을 알 수 있다)
     *
     *      --> 편의성 패치를 통해서 글로벌 변수도 브라우저에서 표시가 된다
     *      --> 변수가 표시되더라도 변수앞에서 호이스팅으로 사용할 수 없어 에러 발생
     */

    var variable = "var 변수";
    let blockLet = "let 변수";
    /**
     *      1. let 변수가 별도의 영역에 설정되는 개념을
     *      - MDN에 "temporal dead zone"으로 기술되어 있다.
     *      - ES6 스펙에 작성된 용어는 아니다
     *
     *      2. temporal 에서 let 변수가 undefined인 상태를
     *      - 나타내는 뉘앙스가 풍기며
     *      --> 왜냐하면 아까 실행하기전에 위에서 찍었을때는 undefined
     *
     *      - dead zone에서 let 변수에 값을 할당한 후에는
     *      - 임시 상태가 해제되어
     *      - 변수를 사용할 수 있다는 뉘앙스가 풍긴다
     *       (즉, let으로 선언한 후에는 사용가능)
     *
     *      3. 아래에서 위의 개념을 같이 정리하겠다.
     */
    debugger;

    /**
     *      1. 개념적인 접근이지만
     *
     *      2. 초기화 단계(코드를 실행하기 전)에서 정적 환경의
     *      - 선언적 환경 레코드에 변수 이름을 바인딩한다.
     *      --> 정적환경 : 프로퍼티로 구성, 거기에 선언적 환경 레코드
     *
     *      3. 이때, var 변수는 undefined를 초깃값으로 설정하고
     *      - let 변수는 초깃값을 설정하지 않는다
     *
     *      4. 엔진에서 이런 처리를
     *      - 초기화자(Initializer)로 구분하고 있다.
     *
     *      5. 변수 이름으로 식별자를 해결할 때
     *      - 변수에 값이 있으면 변수로 인식하고
     *      - 변수에 값이 없으면 변수로 인식하지 않는 개념이다.
     *      --> 즉, temporal 상태가 변수로 인식할 수 있긴 한데 값이 없다라는 것
     *      --> 그리고 변수에다 값을 넣으면 변수가 값을 가지고있기 때문에 그때 변수로 인식하는 개념
     *
     *      6. let 변수 선언을 실행하면 그때 값이 설정되며,
     *      - 값을 할당하지 않고 변수를 선언만 하면
     *      - 엔진이 undefined를 할당한다.
     *      --> 따라서 변수이름과 값을 undefined라도 갖게된다.
     *
     *      --> 그런데 variable 변수는 애당초 처음부터 값을 undefined로 설정하니깐
     *          변수 앞에서 사용할 수 있는것.(호이스팅)
     *
     *      --> 그러나 let 변수는 값을 undefined로 가져가긴 갔지만 단지, 표시를 위한것이지,
     *          실질적으로 엔진관점에서 보면 값을 가지고 있지 않는 상태.
     *
     *      7. 따라서, 변수 선언을 실행한 후에는
     *      - 변수가 값을 갖고 있으므로 변수를 인식할 수 있다.
     *      
     *      8. 엔진에서는 초기화자(Initializer)와
     *      - Binding List 메커니즘을 사용한다
     */
}