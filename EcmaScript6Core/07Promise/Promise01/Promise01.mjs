/**
 * 프로그람 설명문서 주석
 * 2022.03. 16 수업
 *
 *           ===== Promise 개요 =====
 *
 *     - 자바스크립트는 기본적으로 동기로 실행
 *     --> 현재의 실행이 끝나야 다음 코드를 실행
 *
 *     - 한편, Promise 는 비동기로 처리(실행) 한다
 *     --> 코드를 연속으로 처리(실행)하지 않고
 *         중간에 흐름이 끊어졌다가
 *     --> 연결된 코드를 처리할 수 있는
 *         환경이 되었을 때 실행한다
 *     ----> Promise 는 약속이다!.
 *           무슨 약속이냐면, 현재 코드의 실행이 끊어지지만,
 *           환경이 되면 연결된 코드를 실행하겠다라는 시멘틱
 *
 *     --> 이를 위한 메커니즘을 갖고 있다
 *
 *     - DOM 스펙에서 JavaScript 스펙으로 전환되었다
 *     ----> Promise 를 정리하면, Promise 는 비동기로 처리한다는 것이다
 *     ----> 비동기란, 코드를 연속해서 처리하지않고,
 *           인스턴스를 만드는 부분에서 끊어졌다가,
 *           환경이 되었을때, 연결된 코드를 처리한다라는 것.
 */
console.log("=====================================");
// console.log 사용
const { log } = window.console;
/**
 *           ===== Promise 처리 흐름 =====
 *
 *      - Promise 처리(실행) 흐름 개요
 *
 *      - new Promise() 를 실행한다
 *      --> 파라미터의 함수를 실행한다
 *      --> resolve() 를 호출하지 않는다
 *      --> log("Promise") 실행한다
 *      --> obj 변수에 Promise 인스턴스 할당
 *
 *      - obj.then() 을 실행하지 않는다
 *      - 마지막 줄의 log("마지막") 실행한다
 *      - resolve() 실행
 *      --> then() 의 첫 번째 파라미터 함수 실행
 *      --> log("성공") 실행
 *
 */

{
    log('------------ Promise 처리 흐름 개요 ---------------');
    // :: resolve 해결
    // :: reject 거부, 거절
    /**
     *  - new Promise 를 만나면 callback 을 바로 실행하는구나!!
     *  --> 당연한거지 참...ㅋㅋ
     */
    const obj = new Promise(( resolve , reject ) => {
        debugger;
        /**
         *  - 맨 처음 호출한 파라미터를 타네!!
         */
        resolve("성공1");
        // reject 를 호출하면 then 의 두 번째 파라미터를 타는구나
        // reject();
        log( "Promise" );
        debugger;
    });
    debugger;
    // 이게 resolve !!
    obj.then( value => {
       log( value );
       debugger;
    }, reason => {
        log("실패1");
        debugger;
    });
    log("마지막");
    debugger;

    // :: Promise
    // :: 마지막
    // :: 성공

    // 1. new Promise 로 인스턴스 생성,
    //    인스턴스의 then 메소드 작성

    // 2. Promise 내부는 함수이다.
    //    그러면 함수 블록을 실행한다.
    //    이때, resolve 함수를 호출하지 않는다
    // --> 가만히 보면 resolve 를 호출했을때
    //     호출을 받을 함수가 코드내에 없다
    // --> resolve 는 매개변수에 딱, 하나있다
    // --> 이런 형태가 Promise 의 특징이다!

    // 3. log("Promise") 는 실행한다.
    //    이렇게 함수 블록이 끝나면 인스턴스를 생성해서
    //    obj 에 할당한다.

    // 4. obj 에 then 메소드가 있으므로,
    //    obj.then() 을 실행할 수 있지만,
    //    실행하지 않는다.
    // --> 이것이 Promise 의 특징이다.

    /**
     *  - obj 인스턴스를 맨들고 obj.then() 메소드를 호출하면,
     *    흐름이 연결된다. 그런데, then 메소드를 실행하지 않으니깐
     *
     *  --> obj.then() 에서 흐름이 끊어진다
     *      obj.then() 을 실행하지 않고, 내려와서 log("마지막")
     *      을 실행하게 된다.
     *
     *  --> 실행 결과를 보면 Promise 가 먼저 실행되고,
     *      마지막이 실행된다
     *
     *  --> 이렇게 끝까지 처리를 한후, resolve() 를 호출하게 된다.
     *      그러면 then() 의 첫번째 파라미터가 호출된다.
     *
     *  ----> 이렇게 흐름이 끊어졌다가, 실행할수 있는 상태가 되면
     *        resolve 또는 reject 를 호출하게 된다.
     *
     *  ----> resolve 를 호출하면 then 의 첫 번째 파라미터의 함수가
     *        실행되고,
     *        reject 를 호출하게 되면, then 의 두 번째 파라미터의 함수가
     *        실행되게 된다.
     *
     *      =========================================================
     *                  - 이것이 Promise 의 전반적인 흐름이다.
     *      =========================================================
     *
     *  - 인스턴스를 맨들고, then 메소드를 선언하고!
     *    그러나 then 은 실행하지 않고, 아래의 코드들을 실행한 후!
     *
     *  --> resolve 또는, reject 를 호출하면,
     *      then 의 첫 번째 파라미터, 또는 두 번째 파라미터의
     *      함수가 호출된다라는 것
     */

}

/**
 *           ===== Promise 상태 =====
 *
 *      - 상태는 세 가지이며, 동시에 실행하지 않고 하나만 발생한다
 *      --> pending, settled( fulfilled , rejected );
 *          pending :: 기다리는 동안
 *          settled :: 안정적인
 *          fulfilled :: 성취감을 느끼는
 *          rejected :: 거절하다
 *
 *      ----> 세가지는 pending , settled 가 있으며,
 *            settled 는 fulfilled 와 rejected 로 구분된다
 *
 *      ------------------------------------------------------------
 *        |-----------------------------|
 *        | === pending ===             |
 *        |                             |
 *        |       new Promise()         |
 *        |  fulfill, reject 호출 바인딩   |
 *        |-----------------------------|
 *
 *        |-----------------------------------------------|
 *        | === settled ===                               |
 *        |                                               |
 *        |     성공(fulfill)         실패(reject)          |
 *        |        |                    |                 |
 *        |     then(fn) 호출         then( , fn) 호출      |
 *        |                                               |
 *        |-----------------------------------------------|
 *
 *      - 상태를 위와같이 3가지로 구분할 수 있으나.
 *        ===== 상태는 반드시 하나만 발생할 수 있다! =====
 *
 *      --> 그리고 pending 다음에 settled 가 발생하는 것이다.
 *      ------------------------------------------------------------
 *
 *      - pending 상태
 *      --> new Promise() 로 인스턴스 생성
 *      ----> 즉, 인스턴스를 생성하는 시점에서는 pending 상태이다.
 *      --> Promise 성공과 실패 핸들러 함수 바인딩
 */
{
    log('------------ pending 상태 ---------------');
    /**
     * - 인스턴스를 생성하는 시점에서 상태는 pending 이다.
     * --> 첫 번째 파라미터와 두 번째 파라미터가 핸들러 함수이다.
     *     ( resolve , reject ) 가 실행되는 함수
     */
    const obj = new Promise( (resolve , reject) => {
       resolve();
       log( "pending" );
       debugger;
    });
    obj.then( value => {
        log( "성공2" );
        debugger;
    } , reason => {
        log( "실패2" );
    });
    log( "마지막" );
    debugger;
    // :: pending
    // :: 마지막
    // :: 성공2
}
/**
 *           ===== Promise 상태 =====
 *
 *      - settled 상태
 *      --> pending 이 종료된 상태를 나타내며
 *          fulfilled 와 rejected 상태로 구분한다
 *      --> 바인딩한 핸들러 함수가 호출된다
 *
 *      - fulfilled( 성공 ) : then()의 첫 번째 함수 호출
 *
 *      - reject( 실패 ) : then()의 두 번째 함수 호출
 */
{
    log('------------ settled 상태 ---------------');
    /**
     * - 여기서 첫 번째가아닌, 두 번째 파라미터인
     *   reject 를 호출하게 되면
     *
     *  --> then 의 두번째 함수가 호출하는데,
     *      이것은 rejected 상태라는 것이다.
     *
     *  ----> 상태에 따라서, 처리를 하게된다.
     */
    const obj = new Promise( (resolve , reject) => {
        resolve();
        log( "pending" );
        debugger;
    });
    obj.then( value => {
        log( "성공3" );
        debugger;
    } , reason => {
        log( "실패3" );
    });
    log( "마지막" );
    debugger;
    // :: pending
    // :: 마지막
    // :: 성공3

    /**
     *  - 이렇게 상태에 따라서 처리하는 이유가 무엇인가?
     *  --> 동기로 위에서 부터 아래로, 쭉 내려가면서 실행하면,
     *      상태 코드가 필요 없다. 그런데,
     *
     *  --> new Promise 인스턴스를 만들고 resolve 를 호출하는 것은
     *      동기가 아니다.
     *
     *  --> 실행할 수 있는 상태가 되었을 때, resolve 를 호출하게 되는 것이다.
     *
     *     =========================================================
     *            - 상태 코드를 가지고 엔진은 처리를 하게 되는 것이다.
     *     =========================================================
     *
     *  - Promise 내부에서 처리를 다 끝냈는데, 에러가 없다! 한다면,
     *  --> fulfilled 상태로 status 를 설정한다라는 것.
     *      그러면 then 이 호출되었을 때,
     *
     *  --> fulfilled 상태이면 첫 번째 파라미터의 함수를 호출하고,
     *      rejected 상태이면 두 번째 파라미터의 함수를 호출하게 되는 메카니즘이다.
     */
}