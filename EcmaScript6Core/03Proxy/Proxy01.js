/**
 * 프로그람 설명문서 주석
 * 2022.02 19 수업
 *
 *
 *           ===== Proxy(플럭시) =====
 *
 *      - 지금부터 Proxy 와 관련된 것을
 *      --> 3개 섹션으로 나누어 다룬다
 *
 *      - 3개 섹션
 *      --> Proxy (플럭시)
 *      --> Proxy Trap (플럭시 트랩)
 *      --> Reflect
 *
 */
console.log( "=====================================" );
"use strict"
// console.log 사용
const { log } = window.console;
/**
 *
 *           ===== Proxy =====
 *
 *      - Proxy 의 사전적 의미는
 *      --> 대리, 대신
 *      --> 전체 개념에서 볼 때 사전적 의미가 어울린다
 *
 *      - Proxy 는
 *      --> 기본 오퍼레이션(operation)을
 *      --> 중간에서 가로채어 오퍼레이션을 대리, 대신하여 실행한다
 *
 *      - 가로채어 실행하더라도
 *      --> 전체 괘도를 벗어날 수 없으므로
 *      --> 오퍼레이션을 완전하게 바꿀 수는 없다
 *      ----> 예) 값을 구하는 플럭시를 실행한다고 했을 때,
 *                값을 구하지 않고, 값을 설정하는 오퍼레이션!
 *
 *                get 을 하긴하는데, 값을 구하긴 하는데
 *                그런 궤도에서 가로채어 실행한다는 것
 *
 *      - 그럼, 무엇을 대리하고 대신할까?
 *      --> 이것이 Proxy 의 키워드가 된다
 */

/**
 *          ===== 기본 오퍼레이션 =====
 *
 *      - 커피를 주문하는 기본 오퍼레이션
 *      --> 주문을 받는 카운터로 가서 커피를 주문한다
 *      --> 카운터가 커피를 내준다
 *
 *      - 이모습을 자바스크립트 코드로 표현하면
 *
 *      - 여기서 중요한 것은
 *      --> counter.order 가 getter 가 되는 논리이다
 *      --> getter 를 호출하면 value 가 반환되는 근거가
 *          무엇이냐는 것
 */
{
    "use strict";
    log('------------ 기본 오퍼레이션 ---------------');
    const counter = {order: "커피"};
    const 주문자 = counter.order;
    log(주문자);
    // :: 커피
    debugger;

    // 1. {order: "커피"}
    //    order 는 커피를 주문하는 것으로
    //    프로퍼티 key 에 해당하며
    //    "커피"는 프로퍼티 value 에 해당한다

    // 2. const counter = {order: "커피"};
    //    counter 는 주문을 받는 카운터이며
    //    {order: "커피"} 를 갖고 있다
    //    즉, 주문을 받을 수 있으며 커피를 갖고 있다

    // 3. const 주문자 = counter.order;
    //    카운터에게 커피를 주문하면
    //    주문자에게 "커피"를 내주게 된다

    // 4. 자바스크립트로 counter.order 를 실행하면
    //    "커피"가 반환된다

    // 5. 이뗴, 함수를 호출하지 않고 프로퍼티로 값을 구했으며
    //    이것은 getter 이다

    // 6. 즉, getter 를 실행하면 값이 반환된다
    //    이것이 기본 오퍼레이션이다

    // --> setter 를 실행하면 값이 설정될 것이다.

    /**
     *  그런데, 여기서 중요한 것은 counter.order 가 getter 가 되는 논리이다
     *  - counter.order 를 하면 애가 왜 getter 가 되느냐하는 것
     *  --> 무언가 근거가 있어야 한다. 그래야 처리를 할 것 아닌가?
     *
     *  - counter.order 를 실행하면 애는 getter 가 된다!
     *    라는 것이 기본 오퍼레이션이다
     *
     *    그런데 getter 를 호출하면 value 가 반환되는 논리가 무엇이냐는 이야기!
     */
}

/**
 *           ===== 기본 오퍼레이션 논리 =====
 *
 *      - const counter = {order: "커피"};
 *      --> counter.order 를 실행하면
 *      --> "커피"를 구하는 행위를 해야한다
 *      --> 즉, 값을 구하는 메소드가 필요하다
 *
 *      - 이때, 엔진은 getter 기능을 가진
 *      --> 내부 메소드 [[Get]]을 호출한다
 *      ----> 호출한다는 이야기는 [[Get]]은 메소드가 된다
 *
 *      - ES6에 [[Get]] 처럼
 *      --> 기본 오퍼레이션을 제공하는
 *      --> 13개의 내부 메소드가 있다
 *
 *      - ECMAScript 스펙의 기본 오퍼레이션
 */
{
    "use strict";
    log('------------ 기본 오퍼레이션 논리 ---------------');

    const target = {order : "커피"};
    /**
     *  - target.__proto__[[Get]](order)
     *    형식으로 호출하여 값을 구한다는 논리
     *
     *  - 만약 [[Get]]이 없다면 행위도 없는데
     *    값을 구한다는것은 논리가 맞지 않는다
     */
    const value = target.order;
    log(value);
    //:: 커피
    debugger;

    // 1. getter 를 스펙에서 [[Get]] 으로 표기한다

    // 2. const value = target.order;
    //    target.order 를 실행하면
    //    target 오브젝트의 __proto__ 에 있는
    //    [[Get]]을 호출한다

    // 3. [[Get]]을 호출하면서
    //    파라미터 값으로 "order"를 넘겨준다

    // 4. [[Get]] 메소드가 order 를 프로퍼티 키로 하여
    //    프로퍼티 값을 구해 반환한다

    // 5. 이것이 기본 오퍼레이션이다

    /**
     *  - target.order 를 실행하면
     *
     *  - 엔진에 target.__proto__[[Get]](order) 메소드 호출.
     *    그럼 [[Get]] 메소드는 target 오브젝트에서,
     *    order 를 프로퍼티 키로하여 "커피"를 구하는 처리를 하는 것.
     *
     *  - 그리고 구한 값을 반환시켜주는, 그런 행위를 하는 것이 [[Get]]
     */
}
/**
 *  - 핸들러에 관해서는 다음 섹션에서 살펴보겠다!
 */