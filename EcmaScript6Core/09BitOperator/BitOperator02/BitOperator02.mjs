/**
 * 프로그람 설명문서 주석
 * 2022.04. 14 수업
 *
 *           ===== 바이너리 비트 연산자 =====
 *
 *      - Binary Bitwise Operator 개요
 *      --> 왼쪽과 오른쪽에 피연산자가 있는
 *          2항 연산자( 즉, 항이 2개이다 )
 *      --> 왼쪽과 오른쪽 피연산자 값을
 *          비트로 변환하여 연산한다
 *      --> 비트로 연산하므로 처리 속도가 빠르다
 */
console.log("=====================================");
// console.log 사용
const { log } = window.console;
{
    log('------------ 바이너리 비트 연산자 ---------------');
    log( 2 | 5 );
    // :: 7
    debugger;

    // 1. | 가 연산자이고
    //    왼쪽과 오른쪽은 피연산자이다

    /**
     * - 왼쪽과 오른쪽의 값을 비트로 변환하여 연산한다
     *
     * ====== 비트로 연산하므로 처리 속도가 빠르다 ======
     */
}
/**
 *           ===== 비트 OR 연산자 =====
 *
 *      - 연산자 기호 : |
 *      - 피연산자 한쪽이라도 1이면 1로 처리
 *
 *      -----------------------------------------------------------
 *      - 비트            7   6   5   4   3   2   1   0
 *      - 비트 값         128 64  32  16   8   4   2   1
 *      - 값 2           0   0   0   0   0   0    1   0
 *      - 값 5           0   0   0   0   0   1    0   1
 *      - 결과            0   0   0   0   0   1    1   1
 *      -----------------------------------------------------------
 */
{
    log('------------ 비트 OR 연산자 ---------------');
    log( 2 | 5 );
    // :: 7
    log( 7 | 3 );
    // :: 7
    debugger;

    // 1. 양쪽 비트에서 하나라도 1이면 1이 된다
    // 2. ( 4 + 2 + 1 )은 7이다

    /**
     *  - 7 이되려면 0 , 1 , 2 비트가 모두 1이된다
     *    그런데 3은 0 과 1이 1이다
     *  --> 한쪽이라도 겹치면 1로 처리하므로
     *      3은 7 과 겹치므로 7 의 비트값그대로 반환한다
     */
}
/**
 *           ===== 비트 AND 연산자 =====
 *
 *      - 연산자 기호 : &
 *      - 피연산자 한 쪽이라도 0이면 0이 되고
 *        양쪽이 모두 1이면 1이 된다
 *
 *      -----------------------------------------------------------
 *      - 비트            7   6   5   4   3   2   1   0
 *      - 비트 값         128 64  32  16   8   4   2   1
 *      - 값 3           0   0   0   0   0   0    1   1
 *      - 값 5           0   0   0   0   0   1    0   1
 *      - 결과            0   0   0   0   0   0    0   1
 *      -----------------------------------------------------------
 *
 *      --> and(&&) 연산자는 양쪽이 true 일때 true 가 된다.
 *          그런데 비트 and 연산자는 양쪽이 1일때 1이 된다
 */
{
    log('------------ 비트 AND 연산자 ---------------');

    log( 2 & 5 );
    // :: 0
    log( 3 & 5 );
    // :: 1
    debugger;
    // 1. 아 ( 2 & 5 )는 겹치는게 없으므로 0이 되겠구나

    // 2. ( 3 & 5 )는 0번 비트가 겹치니깐 1이 된다.

}
/**
 *           ===== 비트 XOR 연산자 =====
 *
 *      - 연산자 기호 : ^
 *      - 피연산자 양쪽 값이 같으면 0이 되고
 *        하나만 1이면 1이 된다
 *
 *      -----------------------------------------------------------
 *      - 비트            7   6   5   4   3   2   1   0
 *      - 비트 값         128 64  32  16   8   4   2   1
 *      - 값 3           0   0   0   0   0   0    1   1
 *      - 값 5           0   0   0   0   0   1    0   1
 *      - 결과            0   0   0   0   0   1    1   0
 *      -----------------------------------------------------------
 */
{
    log('------------ 비트 XOR 연산자 ---------------');

    log( 3 ^ 5 );
    // :: 6
    debugger;

    // 1. 하나라도 1 이면 1이 된다. 따라서,
    // 2. 1번 비트 + 2번 비트( 4 + 2 )이므로 값은 6이다.
    /**
     *  - XOR 연산자는 딥러닝할때 사용한다
     *  --> 인공신경망의 논리를 XOR 로 풀었다라는... 과정이 존재...
     *      ( 이때, XOR 연산자에 대한 이해가 필요하다 )
     */
}