/**
 * 프로그람 설명문서 주석
 * 2022.04. 15 수업
 *
 *           ===== 비트 NOT 연산자 =====
 *
 *      - 비트( Bitwise ) NOT 연산자
 *      --> 형태 : ~value
 *
 *      - 스펙에는 Bitwise 로 표기되어 있지만
 *      --> 강좌에서는 비트로 표기한다
 *
 *      - 값의 사인 부호를 바꾼다
 *      --> 양수이면 음수로 변환 후, -1을 더하고
 *      --> 음수이면 양수로 변환 후 , 1을 뺀다
 *      --> 2진수 비트로 처리
 */
console.log("=====================================");
// console.log 사용
const { log } = window.console;
{
    log('------------ 비트 NOT(~) 연산자 ---------------');
    log( ~5 );
    // :: -6
    log( ~-5 );
    // :: 4
    debugger;

    // 1. 5를 -5로 변환하고 1을 더한다

    // 2. -5를 5로 변환하고 1을 뺀다
}
/**
 *           ===== << 연산자 =====
 *
 *      - 왼쪽 이동 연산자
 *      --> Left Shift Operator
 *
 *      --> 연산자 오른쪽에 지정한 수 만큼
 *          연산자 왼쪽 비트를 왼쪽으로 이동
 *
 *      -----------------------------------------------------------
 *      - 비트            7   6   5   4   3   2   1   0
 *      - 비트 값         128 64  32  16   8   4   2   1
 *      - 값 3           0   0   0   0    0   0   1   1
 *      - 1 비트          0   0   0   0    0   1   1   0
 *      - 2 비트          0   0   0   0    1   1   0   0
 *      -----------------------------------------------------------
 */
{
    log('------------ 비트 수 만큼 왼쪽으로 이동 ---------------');
    const value = 3;
    log( value << 1 );
    // :: 6
    log( value << 2 );
    // :: 12
    log( value << 3 );
    // :: 24
    log( value << 5 );
    // :: 96
    debugger;

    // 1. value << 1
    //    왼쪽으로 1 비트 이동한다
    //    값이 ( 1 + 2 )에서 ( 2 + 4 )로 바뀐다

    // 2. value << 2
    //    왼쪽으로 2 비트 이동한다
    //    값이 ( 1 + 2 )에서 ( 4 + 8 )로 바뀐다

    // 3. value << 4
    //    결과가 무엇일지 계산해보아라
}
/**
 *          ===== >> 연산자 =====
 *
 *      - 사인 포함 오른쪽 이동 연산자
 *      --> Signed Right Shift Operator
 *
 *      - 연산자 오른쪽에 지정한 수만큼
 *        연산자 왼쪽 비트를 오른쪽으로 이동
 *
 *      - 왼쪽의 사인 부호는 바뀌지 않는다
 *      --> 즉, 양수면 양수 그대로고, 음수면 음수 그대로 남아있다.
 *
 *      - 정수만 사용하므로 소수 이하는 버린다
 *
 *      -----------------------------------------------------------
 *      - 비트            7   6   5   4   3   2   1   0
 *      - 비트 값         128 64  32  16   8   4   2   1
 *      - 값 3           0   0   0   0    1   0   1   0
 *      - 1 비트          0   0   0   0    0   1   0   1
 *      - 2 비트          0   0   0   0    0   0   1   0
 *      -----------------------------------------------------------
 */
{
    log('------------ 비트 수 만큼 오른쪽으로 이동 ---------------');

    const value = 10;
    log( value >> 1);
    // :: 5
    log( value >> 2);
    // :: 2
    log( value >> 4);
    // :: 0
    debugger;

    // 1. value >> 1
    //    오른쪽으로 1비트 이동한다
    //    값이( 2 + 8 )에서 ( 1 + 4 )로 바뀐다

    // 2. value >> 2
    //    오른쪽으로 2비트 이동한다
    //    값이( 2 + 8 )에서 ( 2 )로 바뀐다
    /**
     *  - 소수이하는 버리므로... 1비트 이하보다 작아지면 값을 버린다
     */
}
/**
 *          ===== >>> 연산자 =====
 *
 *      - 사인 부호 없는 오른쪽 이동 연산자
 *      --> Unsigned Right Shift Operator
 *
 *      - 사인 포함 오른쪽 이동 연산자( >> )와 같지만
 *      --> MSB 사인 부호도 이동하는 점이 다르다
 *      --> 이동한 후, MSB 사인 부호 값은 0이다.
 *      ----> MSB 사인 부호( 음수 , 양수 식별하는 부호 )가
 *            0 일때는 이동해도 영향을 미치지 않지만,
 *            1 일때는 이동하면 1이 그대로 같이 이동하므로
 *            값이 크게 차이가난다
 */

/**
 *          ===== 정리 시간 =====
 *
 *      - 목적
 *      --> 비트 연산 논리를 이해하기 위한 것이다
 *
 *      - 값이 음수일 때 코드에서
 *        값이 출력되는 논리를 정리하라
 *
 *      - 힌트
 *      --> 2의 보수 표현법( two's complement )을
 *          참고하라
 *          ( 비트 연산에서 음수를 처리하는 방법 )
 */
{
    log('------------ 2의 보수 표현법 ---------------');
    const value = -10;
    log( value >> 1 );
    // :: -5
    log( value >> 2 );
    // :: -3
    debugger;

    // 1. value 변숫값이 -10 이다
    // 2. 오른쪽으로 1비트 읻오하면 -5가 되고
    // 3. 오른쪽으로 2비트 이동하면 -3이 된다
}