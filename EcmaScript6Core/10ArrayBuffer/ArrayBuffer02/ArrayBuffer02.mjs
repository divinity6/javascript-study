/**
 * 프로그람 설명문서 주석
 * 2022.04. 18 수업
 *
 *
 *           ===== Array 처리 메커니즘 =====
 *
 *      - 자바스크립트는
 *      --> 배열에 엘리먼트 추가, 삭제가 쉽다
 *      --> 추가하면 배열을 늘려야 하고,
 *          삭제하면 배열을 줄여야 한다
 *      --> 삭제 할 때마다 배열을 조정하면 처리 속도가 떨어진다
 *      ----> 예 )
 *            배열의 엘리먼트 100 개 중 10번째것 삭제,
 *            나머지 90개를 앞으로 땡겨야한다. 또한,
 *            추가하면 뒤에 붙여야 한다.
 *            ( 배열이 줄었다 늘었다 하게 된다 )
 *
 *      - Array 처리의 메커니즘
 *      --> 배열의 엘리먼트를 삭제하면
 *      --> 다음의 엘리먼트를 앞으로 당기지 않고
 *          그 위치에 undefined 를 설정한다
 *      --> 엘리먼트 위치를 앞으로 당기면
 *          처리 속도가 떨어지기 때문이다.
 */
console.log("=====================================");
// console.log 사용
const { log } = window.console;
{
    log('------------ Array 처리 메커니즘 ---------------');
    const list = [ 10 , 20 ,30 , 40 ];
    delete list[ 1 ];
    log( list );
    // :: [10, empty, 30, 40]
    debugger;

    // 1. delete list[ 1 ];
    //    1 번 인덱스 값을 삭제한다

    // 2. [ 실행 결과 ] 처럼 undefined 를 설정하고
    //    다음 엘리먼트를 앞으로 당기지 않는다

    /**
     *  - 당긴다라는 것은 시간이 걸린다는 것이다
     *    ( 그래서 그렇게 하지않고,
     *      그 위치에 undefined 를 설정한다는 것 )
     */
}

/**
 *           ===== 메모리 사용 측면 =====
 *
 *      - 자바스크립트의 메모리 사용
 *      --> 값의 크기에 관계없이 64비트( 8 바이트 ) 사용
 *      --> 숫자 1 은 8 비트이면 되므로
 *          64 비트는 필요 이상의 메모리를 사용한다
 *
 *      ----> 1 바이트만 사용하면 되는데 64비트를 전부 사용하니
 *            TypedArray 같은 것이 탄생하게 되었다.
 *
 *      - 데이터 크기가 작으면 영향을 미치지 않지만
 *      --> 이미지( rgba ) 같은 청크( chunk ) 데이터는
 *          메모리 사용의 효율이 떨어지며
 *          처리 속도에도 영향을 미친다
 *      ----> rgba 는 255 까지이므로 64 비트를 사용할 필요가 없이
 *            8 비트만 사용하면 된다.
 *
 *      --> 반복 처리를 많이 하는 머신러닝은
 *          실행 여부 자체에 영향이 미칠 수 있다.
 */

/**
 *           ===== TypedArray 필요성 =====
 *
 *      - 배열 길이가 변하지 않는 형태 필요
 *      --> 처리 속도를 향상시킬 수 있다
 *      --> Int8Array( 100 )
 *      ----> 1 바이트 100 개 선언( 100 바이트 )
 *            101 번째에는 값이 안들어간다
 *            ( 변하지 않는 형태 , 처리 효율 때문 )
 *
 *      - 메모리 사용의 최적화
 *      --> 값 크기에 맞는 메모리 사용
 *      --> Int8Array( 100 ) : 1 은 8 비트로 충분
 *      ----> 값에 맞게 메모리를 최적화해서 사용하겠다!
 *      ----> 값을 사용하는 기본 단위인 8 비트 단위로
 *            사용을 해야한다.
 *
 *      - 바이너리로 데이터 처리
 *      --> 메모리에 값을 저장할 때
 *          0 과 1의 바이너리로 변환하지만
 *      --> 값이 바이너리이므로 처리가 빠르다.
 */

/**
 *           ===== TypedArray 출현 배경 =====
 *
 *      - WebGL 에서 처음 스펙을 작성했으며
 *      --> ES6 에 통합되었다
 *
 *      - WebGL 에서 스펙을 만든 이유
 *      --> 웹에서 청크 데이터 처리를 위해
 *      --> 메모리 사용의 최소화와
 *          빠른 처리가 필요하기 때문
 *
 *      ==================================
 *          - WebGL 은 Canvas 를 가지고
 *            이미지를 처리하는 것이다
 *              ( 엄청 큰 데이터 )
 *          - 거기에는 양수, 음수도 없고
 *            0 ~ 255 밖에 없다
 *            ( 1 바이트면 충분... )
 *      ==================================
 *
 *      - TypedArray 를 사용하는 Web API
 *      --> Canvas 의 ImageData.data
 *      --> FileReader.prototype.readAsArrayBuffer()
 *      --> 이런 유형의 데이터를 사용하는 Web API 에 TypedArray 적용
 *      ----> 빠르고, 최소의 메모리로 사용하겠다라는 것.
 */