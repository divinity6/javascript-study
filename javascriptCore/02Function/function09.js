/**
  * 프로그램 설명문서 주석
  * 2021.04 05 수업
  * 
  *           ===== 오버 로딩 =====
  * 
  *         - 오버로딩 형태
  * 
  *         - 함수 이름이 같더라도
  *         ----> 파라미터 수 또는 값 타입이 다르면 각각 존재
  * 
  *         - 함수를 호출하면
  *         ----> 파라미터 수와 값 타입이 같은 함수가 호출됨
  * 
  *         - JS는 오버로딩을 지원하지 않음
  *         ----> JS는 파라미터 수와 값 타입을 구분하지 않고
  *         ----> { name : value } 형태로 저장하기 때문이다.
  * 
  *         --------------------------------------------------------
  * 
  */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};


window.onload = function() {
      try {
      log('오버로딩 형태');
      function book( one ){};
      function book( one , two){};
      function book( one , two , three ){};

      book( one , two );
      } catch { console.log('자바스크립트에서 지원하지 않음'); }

/**
 *    - 함수 이름이 같더라도 파라미터 수, 값 타입이 다르면 각각 존재하게 된다.
 *    ----> 이것을 오버로딩이라고 한다.
 * 
 *    - 자바스크립트는 오버로딩을 지원하지 않는다.
 *    ----> 그러나 오버로딩을 지원하는 언어는 파라미터 수가 다르거나,
 *          자바스크립트는 파라미터 앞에다 값 타입을 작성하지 않지만,
 *          앞에다 값 타입을 작성하는 언어가 있다.
 * 
 *    ----> 각 함수의 값 타입이 다르면 서로다른 함수가 존재하게 된다.
 *          (이름이 같더라도..)
 *          따라서, 함수를 호출하면 파라미터 수와 값 타입이 같은 함수가 호출된다.
 * 
 *    ----> 예를 들어  book( one , two );를 호출하게 되면, 
 *          function book( one , two){}; 함수가 호출되는 것.
 *          이것을 오버로딩이라고 한다.
 * 
 *    ----> 그런데, 자바스크립트는 오버로딩을 지원하지 않는다.
 *          자바스크립트는 파라미터 수와 값 타입을 구분하지 않고 { name : value } 형태로
 *          저장하기 때문에 그렇다.
 * 
 *    - 이에 대한 논리.
 */

      function book(){
            function getBook(){
                  return "책1";
            };

            getBook();

            function getBook(){
                  return "책2";
            };
      };
      book();


/**
 *          ===== 오버로딩 미지원 : 함수 선언문 초기화 =====
 * 
 *    1. 마지막 줄에서 book()함수를 호출하면
 * 
 *    2. function getBook(){return "책1";}을 만나
 *    ----> getBook 오브젝트를 생성한다.
 * 
 *    3. getBook()을 호출하지 않고 아래로 내려간다.   
 * 
 *    4. function getBook(){ return "책2"; }를 만나
 *    ----> getBook 오브젝트를 생성한다
 *    ----> 2번의 오브젝트와 이름이 같으므로
 *    ----> 여기서 생성한 getBook 오브젝트로 [[대체]]된다
 * 
 *    5. { name : value } 형태에서
 *    ----> 이름(name)이 같으므로 값(value)이 변경된다.
 * 
 *    
 *    =======================================================================
 *    =======================================================================
 * 
 *          ===== 오버로딩 미지원 : 변수 초기화 =====
 * 
 *    6. book 함수의 첫 번째 줄로 이동한다.
 *    
 *    7. 함수 표현식과 변수에 undefined를 설정하지만
 *    ----> 설정할 대상이 없다
 * 
 *    8. 다시 book 함수의 첫 번째 줄로 이동한다
 *    
 *    =======================================================================
 *    =======================================================================
 * 
 *          ===== 오버로딩 미지원 : 코드 실행 =====
 * 
 *    9. function getCoffee(){ return "커피1"; };
 *    ----> 함수 선언문이므로 아래로 내려간다.
 * 
 *    10. getCoffee() 함수를 호출한다
 * 
 *    11. return "커피2"의 getCoffee 함수가 실행된다
 *    ----> 함수 이름이 같으므로
 *          위의 함수가 아래 함수로 대체되었기 때문이다
 *    ----> "커피2"가 [실행결과]에 출력된다
 * 
 *    12. 호출한 함수로 돌아와 다음 코드를 수행한다.
 * 
 *    13. function getCoffee(){ return "커피2"; };
 *    ----> 함수 선언문이므로 처리하지 않는다.
 * 
 */

      function coffee(){
            function getCoffee(){
                  return "커피1";
            };
            // 여기서 호출
            console.log(getCoffee());
            function getCoffee(){
                  return "커피2";
            };
      }
      coffee();

/**
 *    - 이와같은 논리로 자바스크립트는 오버로딩을 지원하지 않는다
 *    ----> 즉, { key : value }, { name : value }의 프로퍼티인 것이다.
 *          이것이 자바스크립트의 가장 기본이되는 구조이다.
 * 
 */
  
};
