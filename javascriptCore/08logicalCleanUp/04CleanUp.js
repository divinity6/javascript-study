/**
 * 프로그램 설명문서 주석
 *  2021.07.20 수업
 *
 *
 *              ===== 클로저와 무명함수 =====
 *
 *      ----- 클로저와 무명함수의 활용 정리하는 차원 -----
 *
 *      - 무명 함수안에 작성한 값, 함수는
 *      --> 무명 함수가 끝나면 지워진다 (날아간다.)
 *      --> 따라서 다시 사용하려면 저장 필요
 *      --> 한편, 무명 함수는 원래 저장하지 않으려는 의도로 사용
 *
 *      - 클로저 활용
 *      --> 클로저는 함수 밖 스코프의 변수와 함수를 사용할 수 있음
 *      --> 변수는 외부에서 직접 접근할 수 없으므로 정보 보호
 *      --> 무명 함수 안에서 클로저의 변수를 가진 함수를 반환하면
 *          함수의 재사용과 정보 보호를 할 수 있다. (두마리 토끼를 다자븜)
 *
 */


console.log('-------- Object 할당 ----------');
"use strict"
// console.log 사용
var log = function (value) {
    console.log('--- ' + value + ' ---');
};

/**
 *              ===== 클로저와 무명함수 =====
 *
 *      - function getPoint(param){...}
 *      --> [[Scope]]에 스코프 설정
 *
 *      - return getPoint;
 *      --> 즉시 실행 함수에서 getPoint 함수 반환
 *      --> book 변수에 할당
 *      --> point 변숫값을 사용할 수 있다.
 *
 *      - console.log(book(200));
 *      --> 반환된 함수를 호출하면서
 *          200을 파라미터 값으로 넘겨 준다.
 *
 *      - function getPoint(param){
 *          return point + param;
 *      };
 *      --> getPoint function 오브젝트의 [[Scope]]에
 *          바인딩 되어있는 point를 외부렉시컬 참조에다
 *          바인딩 시킨다.
 *
 */

log('클로저와 무명 함수');
var book = (function () {
    var point = 100;

    // param에 200이 매핑
    function getPoint(param) {
        debugger;
        return point + param;
    };
    return getPoint;
}());

// getPoint의 closer는 book안
console.log(book(200));
// :: 300

/**
 *      - 지금까지 보면 함수 안에 있는 것들은 날아가지 않았다.
 *        (일반적으로 날아가야 하지만 return을 하게 됨으로 써,
 *         전부 살아있게 된다. var point도 살게된다.
 *         왜냐, 이것은 전부 getPoint의 내부프로퍼티인 [[Scope]]에 바인딩
 *         되어있기 때문이다 )
 *
 *      - 함수가 호출되면 [[Scope]]에 있는것을 외부렉시컬 환경 참조에다가 바인딩 시킨다.
 *        그 스코프에는 point 변수가 있다.
 *        (getPoint안에는 point 변수가 없지만 point변수를 식별자 해결할 수 있다.)
 *
 */

/**
 *              ===== JS에서 클로저 =====
 *
 *      - 함수에서 함수 밖의 변수 사용은
 *      --> JS의 기본적인 메커니즘
 *
 *      - 논리적 근거는
 *      --> 외부 렉시컬 환경 참조에
 *          함수가 속한 스코프가 설정되기 때문이다.
 *
 *      - 클로저는 단지 이를 나타내는 용어일 뿐
 *      --> 영어보다 논리적 구조 이해
 *          (논리적으로 이해하면 클로저 외에도 다른것
 *          들을 논리적으로 접근할 수 있기 때문이다)
 *
 */

/**
 *
 * 즉시실행 익명함수는 함수 안에 작성한 변수(var)를,
 * 함수를 빠져나오면 자동으로 GC 처리를 하게됩니다.
 * 즉, 메모리에서 지워지므로 변수가 남지 않습니다.
 *
 * 그래서 일반적으로 초깃값을 설정하는 것과 같이 한 번만 처리할 때 사용합니다.
 * 또한, 함수 안의 변숫값을 유지하려면 지워지지 않는 곳에 저장해야 하는데요,
 *
 * ES5에서는 특정 오브젝트에 저장하고 ES6+에서는 주로 Map 오브젝트에 저장합니다.
 * 정보보호 차원에서는 클로저 형태가 좋습니다.
 *
 * 아울러 대상에 차이가 있지만 ES5의 디스크립터를 사
 * 용하여 정보 보호를 할 수도 있습니다.
 *
 */