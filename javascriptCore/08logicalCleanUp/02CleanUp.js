/**
 * 프로그램 설명문서 주석
 *  2021.07.12~15 수업
 *
 *
 *              ===== 즉시 실행 함수 =====
 *
 *      - 함수 즉시 실행이란?
 *      --> 엔진이 함수를 만났을 때
 *      --> 자동으로 함수를 실행
 *      --> 즉시에 실행하므로 즉시 실행 함수
 *
 *        (즉시 호출되는 함수 표현식)
 *      - IIFE : Immediately Invoked Function Expression
 *
 *      - (function(){...}()) 형태
 *      --> 함수 이름이 없으므로
 *          함수 선언문, 함수 표현식도 아님
 *      --> 문법 에러가 발생하지 않음
 *      --> 무명 함수, 익명 함수라고도 부름
 *
 *      -------------------------------------------------------
 *
 *      - 함수 즉시 실행이란? 엔진이 함수를 만났을 때 자동으로 함수를 실행.
 *      --> 즉, 엔진이 function 키워드를 만나면 function 오브젝트를 생성하고,
 *          곧바로 함수를 실행한다.
 *
 *      --> 즉시에 실행하므로 즉시 실행 함수라고 한다.
 *
 */


console.log('-------- Object 할당 ----------');
"use strict"
// console.log 사용
var log = function (value) {
    console.log('--- ' + value + ' ---');
};

log('함수 즉시 실행');
// function 키워드를 만나면 바로실행을 해버린것.
// 그래서 JS북이 출력되었다.
(function () {
    console.log("JS북");
    // :: JS북
}());
/**
 *  - 함수는 호출을 해야하는데 이것은 호출을 하지않고 바로 실행하는 것.
 *    따라서, 함수 즉시 실행이다.
 *    (이것을 IIFE라고 부른다)
 *
 *  - 여기서 Function Expression에대해서 생각을 해봐야한다.
 *      (Function Expression == 함수 표현식)
 *  --> Function Expression을 가지고 논리적으로 전개.
 *
 *  - (function(){...}()) 형태는
 *  --> 함수 이름이 없으므로 함수 선언문, 함수 표현식도 아님
 *      ( 이름도없고 할당도 없음 )
 *  --> 이것을 무명함수, 또는 익명함수라고도 부른다.
 */

/**
 *              ===== 함수 즉시 실행 과정 =====
 *
 *      - 표현식을 평가
 *      --> 소괄호()는 그룹핑 연산자
 *
 *      - 함수 이름 필요
 *      --> 함수에 이름이 없으면 문법 에러
 *
 *      - 함수 표현식 끝에 소괄호 작성
 *      - 소괄호()에 함수 작성
 */

log('표현식 해석');
var total = (1 + 2);
console.log(total);
// :: 3

// 1. ( 1 + 2 ) 형태에서
//  소괄호()는 그룹핑 연산자이며 1 + 2는 표현식

// 2. 그룹핑 연산자는 소괄호 안의 표현식을 평가하고
//    평가 결과를 반환 (저장하지도 않는다)

// (그룹핑연산자에서)반환한걸 total에 할당하네

// --> 계산결과만 반환하지, 도중에 있던것들은 가비지 컬렉션이 전부 긁어간다.
// --> 그렇지 않으면 메모리에서 뭔가 지우는 처리를 한다.

// 3. 소괄호()와 표현식 평가가 키포인트

log('함수 이름 필요');
var value = function () {
    return 100;
};

console.log(value());
// :: 100

// 1. 함수 표현식으로 엔진이
//    function 키워드를 만나면
//    function 오브젝트를 생성하여 value 변수에 할당

// 2. value 변수를 선언하지 않으면
//    함수 이름이 없으므로 문법 에러
//    함수 표현식도, 함수 선언문도 아니기 때문이다.

// 3. value()처럼 function 끝에
//    소괄호()를 첨부하면 함수로 호출
//    이때, 소괄호()는 그룹핑 연산자가 아닌 함수 호출하는 역할


log('끝에 소괄호 작성');
var value2 = function () {
    return 100;
    // 소괄호가 있으므로 바로 함수 호출되네
    // 그래서 value2에는 바로 값이 할당되어 버리는 구나
}();

// function 오브젝트를 value2에 할당하지않고, 즉시 실행해서 return 100을 할당하네

console.log(value);
// :: ƒ () { return 100; }
console.log(value2);
// :: 100

// 1. 함수 끝에 소괄호를 첨부한 형태
// 2. function 키워드를 만나 function 오브젝트 생성
// 3. 소괄호가 있으므로 함수 호출
// 4. 함수에서 반환한 100을 value 변수에 할당


log('소괄호()에 함수 작성');

// 여기서 function 앞에있는 ( 는 그룹핑연산자 였네.

// 그룹핑 연산자이므로 이안을 먼저 평가함
// 그런데 표현식이 함수인 것이다. 그래서,
// function 오브젝트를 만들게 되고, 실행하게 된다.
// 그리고 밖의 ()소괄호는 단지 그룹핑연산자이다.

var value3 = (function () {
    return 100;
}());

console.log(value3);
// :: 100

// 1. 소괄호 안에 함수 작성
// 2. 소괄호는 그룹핑 연산자
// 3. 그룹핑 연산자이므로 소괄호 안의 [[표현식]]을 평가
// 4. 표현식이 함수이므로 function 오브젝트 생성
// 5. function 끝에 소괄호가 있으므로 함수 실행

/**
 *              ===== 이것이 함수를 즉시 실행하는 논리적 과정이다 =====
 */


/**
 *              ===== 함수 즉시 실행 과정 =====
 *
 *      1. 그룹핑 연산자(소괄호)에서 반환된 값이
 *         할당되는 변수를 작성하지 않은 형태
 *
 *      2. (function(){})()처럼 소괄호를 끝에 작성 가능
 */


/**
 *              ===== 함수 즉시 실행 과정 =====
 *
 *      1. 그룹핑 연산자를 작성하지 않으면
 *         함수 이름이 없으므로 문법 에러
 *
 *      2. 하지만, 그룹핑 연산자를 작성하면
 *         표현식에 function을 작성한 것이므로
 *         문법 에러가 발생하지 않는다
 *
 *         즉, (1 + 2)에서 1 + 2 대신에 함수를 작성한 것
 *
 *      3. 표현식과 표현식 평가 결과는
 *         [[평가 결과가 반환할 때까지 메모리에 저장]]하고
 *         평가 결과를 반환하면 지워진다
 *
 *      4. (1 + 2)의 결과가 메모리에 저장된다면
 *         매우 많은 메모리가 필요할 것이다
 *
 *      5. function(){}();
 *         코드로 만든 오브젝트도 메모리에 저장되지 않으며
 *         실행 결과도 메모리에 저장되지 않는다
 *         (이름이 있어야 저장할 것 아닌가, 메모리에 저장한다는
 *          이야기는 그것을 재활용 하겠다는 뜻. - 목적이 재활용하지 않겠다는 뜻)
 *
 *      6. 따라서 저장해야 할 것이 있다면
 *         표현식 밖의 변수 또는, 프로퍼티에 저장해야 한다.
 *
 *      7. 저장할 필요가 없는 1회성 코드이면서
 *         엔진이 function 키워드를 만나는 시점에
 *         즉시 실행해야 한다면
 *
 *      8. 그룹핑 연산자 안에 표현식으로 작성
 *
 *      9. 무명 함수는 그룹핑 연산자 안의 코드를
 *         [["한 번만 사용할 때 사용"]]한다.
 *
 *      10. 대부분(주로) 초깃값을 설정할 때 사용한다.
 *
 *      --> 초깃값은 값이 바뀐다. 그럼 초기에 설정했던
 *          코드는 필요가 없다. 그럴 때 깔끔하게 날려버리기 위해...
 *
 *      ===== 함수 이름을 준다는 것은 어딘가에 저장이 된다는 뜻.(그것을 하지 않겠다라는 것) =====
 *            한번만 쓰고 버리겠다는 뜻(용도)
 *
 *
 */

log('값 반환을 사용하지 않음');

(function () {
    console.log(100);
}())
// 이형태는 할당도 하지않고 바로 실행하고 100이 출력되었다.


log('()를 그룹핑연산자 밖에 사용');

(function () {
    window.value4 = 100;
})();

console.log(value4);

debugger;
log('그룹핑연산자 실행 순서(파라미터)(넘겨주는 값)');
(function (value) {
    console.log(value);
    console.log('실행{}');
    debugger;
}((function () {
    var value = '실행()';
    return value;
}())))