/**
 * 프로그램 설명문서 주석
 *  2021.07.18 수업
 *
 *
 *              ===== 클로저(Closure) 논리 =====
 *
 *              클로저 === [[ 변수가 선언적 환경 레코드에 없으면 외부 렉시컬 환경 참조에서 식별자 해결 ]]
 *
 *      - Closure
 *      --> function 오브젝트를 생성할 때
 *          함수가 속한 스코프를 [[Scope]]에 설정하고
 *      --> 함수가 호출되었을 때
 *          [[Scope]]의 프로퍼티를 사용하는 메커니즘
 *
 *      - 따라서 [[Scope]]의 설정과 사용방법을 이해하면 클로저는 단지 논리적인 설명
 *
 */


console.log('-------- Object 할당 ----------');
"use strict"
// console.log 사용
var log = function (value) {
    console.log('--- ' + value + ' ---');
};

/**
 *              ===== 클로저(Closure) 논리 =====
 *
 *      --------------------------------------------------------
 *              실행 콘텍스트 : {
 *                  렉시컬 환경 컴포넌트 : {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {(함수 안에 작성한 것)},
 *                          오브젝트 환경 레코드 : {}
 *                      },
 *                      외부 렉시컬 환경 참조 : {(함수가 속한 스코프를 바인딩)}
 *                  }
 *              }
 *      --------------------------------------------------------
 *
 *      - 함수가 호출되면 실행 중인 function 오브젝트에
 *      --> 작성한 변수, 함수를 선언적 환경 레코드에 설정
 *
 *      - [[Scope]]의 변수, 함수를
 *      --> 외부 렉시컬 환경 참조에 바인딩
 *
 *      --> 그럼으로써 변수 이름으로 접근하여 값을 사용하거나 변경할 수 있음
 *          ( 콘텍스트 개념으로 실행 콘텍스트 안에 들어가 있기 때문이다.
 *          즉, 외부 렉시컬 환경 참조에 있는 것도 마치 내것처럼 쓰는 것 .
 *          따라서 값을 변경할 수 있는 것이다.)
 *
 *      - 또한, 함수를 호출할 수도 있음
 *
 *      ===> 이러한 개념이 바로 클로저 논리이다.
 *           외부 렉시컬 환경 참조에 있는 것을 내것처럼 쓰겠다는 것이다.
 *           (그것이 클로저 논리이다)
 *
 *      ===> 콘텍스트 구조를 가지고 있기 때문에 콘텍스트를 이해만 한다면,
 *           클로저 논리는 간단한 것이다.(simple)
 *
 *      ===> 외부 렉시컬 환경참조에 있는 변수와 함수를 마치 내것 처럼 쓰는 것(끝)
 *
 */


/**
 *              ===== 코드를 따라가며 전개 =====
 *
 *      - book()함수 호출,
 *        그러면 변수설정(point) 후
 *        function 오브젝트를 만들어서 getPoint에 할당.(getPoint)
 *        그리고 getPoint함수를 반환.
 *
 *      - 그러면 obj에 getPoint함수가 할당. (obj = book())
 *        그 후 getPoint함수를 호출(obj(200))
 *
 *      그러면 getPoint안에서 어떤처리를 한다. 이러한 시나리오
 *
 */

/**
 *              ===== 클로저(Closure) 논리 전개 =====
 *
 *      1. var obj = book();
 *      - book()을 호출하면 엔진은 아래방법으로 처리
 *      - getPoint()의 클로저가 만들어진다.
 *        ( return getPoint 에서 만들어짐 )
 *
 *      -------------------
 *         실행 준비 단계
 *      -------------------
 *
 *      2. 실행 콘텍스트(EC) 생성
 *
 *      3. 3개의 컴포넌트 생성
 *      - 렉시컬/변수 환경 컴포넌트,
 *        this 바인딩 컴포넌트
 *
 *      4. function 오브젝트의 [[Scope]]를
 *      - 외부 렉시컬 환경 참조에 바인딩
 *
 *      === 여기까지 모습 ===
 *      --------------------------------------------------------
 *              실행 콘텍스트 = {
 *                  렉시컬 환경 컴포넌트 : {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {}
 *                          오브젝트 환경 레코드 : {}
 *                      },
 *                      외부 렉시컬 환경 참조 : { [scope] }
 *                  },
 *                  변수 환경 컴포넌트 : {},
 *                  this 바인딩 컴포넌트: {}
 *              }
 *      --------------------------------------------------------
 *
 *      -------------------
 *       초기화 및 실행 단계
 *      -------------------
 *
 *      5. var point; var getPoint;
 *      - 변수 이름을 선언적 환경 레코드에 설정
 *      -->  이 때 값은 undefined이다
 *      --> 내려와서 다시올라감. 이번엔 실행을 한다
 *
 *      6. var point = 100;
 *      - 선언적 환경 레코드의 point에 100할당
 *
 *      7. var getPoint = function(param){코드};
 *      - function 오브젝트 생성
 *      - 스코프를 내부프로퍼티인 [[Scope]]에 바인딩
 *      --> 즉, book()안 전체가 바인딩 되는 것.
 *      --> 따라서, point:100이 스코프에 바인딩 된다.
 *      - point:100이 [[Scope]]에 바인딩 된다
 *
 *      ==== getPoint 오브젝트 모습 ===
 *      --------------------------------------------------------
 *              실행 콘텍스트 : {
 *                  렉시컬 환경 컴포넌트: {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {},
 *                          오브젝트 환경 레코드 : {}
 *                      },
 *                      렉시컬 환경 참조 : {
 *                          point: 100
 *                      }
 *                  },
 *                  변수 환경 컴포넌트 : {},
 *                  this 바인딩 컴포넌트 : {}
 *              }
 *
 *      --------------------------------------------------------
 *
 *      8. return getPoint;
 *      - getPoint function 오브젝트 반환
 *
 *      9. var obj = book();
 *      - return getPoint에서 반환한
 *      - getPoint function 오브젝트를 obj에 할당
 *
 *      10. console.log(obj(200));
 *      - obj()를 호출하면
 *        getPoint(200) 함수가 호출된다
 *      - 클로저와 관련된 부분만 추려보면 아래를 처리하게 된다
 *
 *      -----------------------------
 *       getPoint의 클로저와 관련된 부분
 *      -----------------------------
 *
 *      --> obj(200)을 하게되면, getPoint 함수를 호출. 그러면
 *
 *      11. 실행 콘텍스트(EC) 생성
 *      - getPoint 오브젝트의 [[Scope]]를 외부 렉시컬 환경 참조에 바인딩
 *      - 파라미터 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정
 *
 *      ==== 여기까지 모습 ===
 *      --------------------------------------------------------
 *              렉시컬 환경 컴포넌트 : {
 *                  환경 레코드 : {
 *                      선언적 환경 레코드 : {
 *                          param : 200
 *                      },
 *                  },
 *                  외부 렉시컬 환경 참조 : {
 *                      point: 100
 *                  }
 *              }
 *
 *      --------------------------------------------------------
 *
 *
 *      12. 이제 함수 안의 코드 실행
 *
 *      13. point = point + param;
 *      - point를 선언적 환경 레코드에서 식별자 해결
 *      --> 그런데 point가 없으므로 외부 렉시컬 환경 참조에서 식별자 해결
 *      --> point가 있으며 값이 100이다.
 *
 *      - param을 선언적 환경 레코드에서 식별자 해결
 *      --> param이 있으며 값이 200이다
 *      --> 100과 200을 더해 외부 렉시컬 환경 참조의 point에 할당
 *
 *      14. [[ 변수가 선언적 환경 레코드에 없으면 외부 렉시컬 환경 참조에서 식별자 해결 ]]
 *
 *      15. ## 이것이 클로저 논리이다 ##
 */


console.log('클로저 논리 전개');

function book() {
    debugger;
    var point = 100;
    var getPoint = function (param) {
        point = point + param;
        return point;
    };
    return getPoint;
};

var obj = book();
console.log(obj(200));
// :: 300


/**
 *              ===== 정리 시간 =====
 *
 *          요구 사항
 *          - 값이 출력되는 논리를 설명하세요.
 *
 */


console.log('정리 시간');

function coffee(bookParam) {
    var point = 100;

    function getPoint(pointParam) {
        point = point + bookParam + pointParam;
        return point;
    }

    return getPoint;
}

var obj2 = coffee(200);
console.log(obj2(400));
// :: 700

/**
 *      논리
 *
 *
 *      1. 함수 선언문인 book에 function 오브젝트를 할당한다
 *         1) book의 [[Scope]]에 스코프를 바인딩한다
 *
 *
 *      2. obj를 만나면 { obj : book(200){...}} 형태로 할당하고 실행콘텍스트를 만든다
 *         1) book의 [[Scope]]를 외부 렉시컬 참조에 설정한다.
 *         2) book의 파라미터인 200을 선언적 환경 레코드에 설정한다.
 *         ---------------------------------------------------
 *              실행 콘텍스트 : {
 *                  렉시컬 환경 컴포넌트 : {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {
 *                              bookParam : 200
 *                          }
 *                      },
 *                      외부 렉시컬 환경 참조 : {글로벌}
 *                  }
 *              }
 *         ---------------------------------------------------
 *
 *
 *      3. 엔진컨트롤이 함수안으로 이동하여 초기화를 진행한다(함수 선언문이 없으므로)
 *          1) 선언적 환경레코드에 point: undefined를 설정한다.
 *
 *      4. 함수 실행단계로 넘어가
 *          1) point: 100으로 할당된다.
 *          2) getPoint: function(){...} (getPoint를 만나 function 오브젝트를 할당한다 이때)
 *          ---> 이때 getPoint의 스코프가 결정된다.
 *          3) getPoint를 반환한다
 *
 *         ---------------------------------------------------
 *              실행 콘텍스트 : {
 *                  렉시컬 환경 컴포넌트 : {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {
 *                              bookParam : 200,
 *                              point : 100,
 *                              getPoint : function(){}
 *                          }
 *                      }
 *                  }
 *              }
 *         ---------------------------------------------------
 *
 *      5. 엔진컨트롤이 return getPoint를 만나면 getPoint를 반환하고 obj2에 할당한다.
 *
 *      6. 그후 console.log(obj2(400))을 만나면 실행컨텍스트를 만들고
 *         1) getPoint의 [[Scope]]를 외부렉시컬 참조에 설정하게 된다.
 *         2) pointParam에 obj2의 400을 할당한다
 *         ---------------------------------------------------
 *              - getPoint -
 *              실행 콘텍스트 : {
 *                  렉시컬 환경 컴포넌트 : {
 *                      환경 레코드 : {
 *                          선언적 환경 레코드 : {
 *                              pointParam : 400,
 *                          }
 *                      },
 *                      외부 렉시컬 환경 참조 : {
 *                          bookParam : 200
 *                          point: 100,
 *                      }
 *                  }
 *              }
 *         ---------------------------------------------------
 *
 *      7. 엔진컨트롤이 getPoint 안으로 이동하여
 *          1) 함수 선언문이 없으므로 초기화를 진행한다
 *          2) 그러나 함수나 변수가없다
 *
 *      8. 실행단계로 넘어가는데
 *          1) point,bookParam 선언적환경레코드에서 찾아봤는데 없다
 *          2) pointParam은 존재한다. 따라서 pointParam : 400이된다
 *          3) 그후 point,bookParam는 외부렉시컬 환경 참조에 들어가있으므로
 *             point: 100이되고 bookParam : 200 이된다.
 *          4) point = point(100) + bookParam(200) + pointParam(400)을 실행
 *
 *      9. 700을 반환하게 된다.
 *
 *
 *
 *
 *  ==== 외부 렉시컬 참조 시 ===
 *  
 * 계층적으로 밖에 있는 스코프를 참조한다. 
 * 우선 1단계 밖에 있는 프로퍼티를 찾고, 거기에 없으면 
 * 다시 2단계 밖에 있는 프로퍼티를 찾는다(식별자 해결). 
 * 그래도 없으면 같은 방법으로 글로벌 오브젝트까지 올라가서 프로퍼티를 찾는다.
 *
 *
 *
 */


// 1. book function 오브젝트를 생성
//
// 2. book 함수가 속한 글로벌 오브젝트를 function 오브젝트의 [[Scope]]에 설정
//
// 3. var obj = book(200); 에서 book(200)을 호출
//
// --실행 준비 단계--
// 4. 실행 콘텍스트를 생성
//
// 5. 3개의 컴포넌트 생성 (렉시컬/변수 환경 컴포넌트, this 바인딩 컴포넌트)
//
// 6. book function 오브젝트의 [[Scope]]를 외부 렉시컬 환경 참조에 바인딩
//
// --초기화 및 실행 단계--
// 7. 파라미터 이름인 bookParam에 200을 매핑하여 선언적 환경 레코드에 설정
//
// 8.function getPoint(pointParam){코드}에서 function 오브젝트를 생성
//
// 9. getPoint function 오브젝트의 [[Scope]]에 book 함수의 내부 영역이 설정됨
//
// 10. getPoint를 선언적 환경 레코드에 설정
//
// 11. var point;에서 변수 이름을 선언적 환경 레코드에 설정
//
// 12. var point = 100;에서 선언적 환경 레코드의 point에 100 할당
//
// 13. return getPoint;에서 getPoint function 오브젝트 반환
//
//
//
// 14. obj에 getPoint function 오브젝트를 할당
//
// 15. console.log(obj(400))에서 obj를 호출하면 getPoint(400) 함수가 호출됨
//
// --getPoint 함수의 클로저와 관련된 부분--
// 1. 실행 콘텍스트를 생성
//
// 2. getPoint function 오브젝트의 [[Scope]]를 외부 렉시컬 환경 참조에 바인딩
//
// 3. pointParam이라는 파라미터 이름에 400을 매핑하여 선언적 환경 레코드에 설정
//
//
//
// 4. 함수 안의 코드 실행
//
// 5. point = point + bookParam + pointParam;에서
//
// 6. point와 bookParam을 외부 렉시컬 환경 참조에서, pointParam을 선언적 환경 레코드에서 식별자 해결
//
// 7. 각각을 더한 값을 ponit에 할당
//
// 8. 따라서 콘솔창에 700이 출력됨
