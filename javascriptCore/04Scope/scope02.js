/**
  * 프로그램 설명문서 주석
  * 2021.04 08 수업
  * 
  *           ===== 글로벌 오브젝트 =====
  * 
  *   - var value = 100;
  *   ----> 100을 value 변수에 할당한 것은
  *   ----> value로 검색하여 값을 다시 사용하기 위한 것
  * 
  *   - 함수 안에 변수를 선언하면
  *   ----> 변수가 함수에 속하게 되지만
  * 
  *   - value 변수를 함수 안에 작성하지 않음
  *   ----> value 변수가 속하는 오브젝트가 없으며
  *   ----> 이때, 글로벌 오브젝트가 설정된다
  * 
  *   - 이런 메커니즘을 구현할 수 있는 것은
  *   ----> 글로벌 오브젝트가 하나만 있기 때문이다.
  */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};

var value = 100;
function book(){
      var point = 200;
      return value;
};
book();

/**
 *    - 이와같이 book()안에 point를 선언하면
 *      book() 오브젝트에 point 변수가 속하게 되지만
 *    ----> value는 오브젝트가 위에 없다.
 * 
 *    ----> 이때, 글로벌 오브젝트에 설정된다.
 *          변수를 싸고 있는 오브젝트가 없으면, 이것은 글로벌
 *          오브젝트에 설정된다.
 * 
 *    ----> 이런 메커니즘을 구현할 수 있는 것은
 *          글로벌 오브젝트가 하나만 존재하기 때문이다.
 * 
 *    - 오브젝트가 하나이므로 굳이 오브젝트를 작성하지 않더라도
 *      글로벌 오브젝트에 속하게 한다라는, 이자체는 굉장히 좋은 접근이다.
 * 
 *    ----> 그러나 현재는 굉장히 많은 오브젝트를 사용하게 되고, 그러다보니
 *          문제가 발생하긴 하지만, 그래도 오브젝트에 속하지 않으면 글로벌
 *          속한다는 그 자체만으로는 접근이 괜찮았다.
 * 
 */

/**
 *          ===== 글로벌 오브젝트 특징 =====
 * 
 *    - JS 소스 파일 전체에서
 *    ----> 글로벌 오브젝트는 하나만 있다.
 *    ----> 따라서 new 연산자로 인스턴스 생성 불가
 * 
 *    - JS 소스 파일 전체 기준
 *    ----> <script>에 작성된 모든 코드
 *    ----> 모든 코드에서 사용 가능
 * 
 *    - def.js 파일의 코드에서
 *    ----> 글로벌 오브젝트에 작성된
 *    ----> 변수 value 값을 출력하고
 *    ----> book() 함수를 호출
 * 
 */

var value = 100;
function book(){
      return value + 50;
};
debugger;
console.log( valueTest );
// :: 100
console.log( bookTest() );
// :: 150

/**
 *    - 만약에 new 연산자로 인스턴스를 생성할 수 있다고 한다면
 *      하나만 있다는 전제가 깨지는 것이다.
 * 
 *    - 여기서 JS 소스 파일 전체의 기준은
 *      <script>에 작성된 모든 코드가 기준이다.
 *    ----> 묵시적으로 만들어져 있어 모든 파일을통해서 하나만 존재한다
 * 
 *    - 빌트인 오브젝트이긴 하다. 글로벌 오브젝트는, 형체가 없다라는 것이
 *      문제이긴 하지만, 개념적으로 글로벌 오브젝트는 존재하며 하나있다라는 것이다.
 * 
 *    ----------------------------------------------------------------------------
 * 
 *    - 결국 위의 valueTest 라는 것이 어딘가의 스코프에 저장되어 있을 것이다.
 *      그것이 바로 글로벌 오브젝트인 것이다.
 * 
 *    - 그래서 console.log(valueTest)를 하게되면 글로벌 오브젝트에 가서 
 *      valueTest를 찾는 것이다. 식별자 해결을 하는 것이다.
 * 
 *    ----> 그런데 글로벌 오브젝트에 가서 valueTest가 있는 것이다.
 *          그래서 값을 출력할 수 있는 것이다.
 * 
 *    - 이 파일에서 bookTest()를 호출 했다. 그런데 이 파일안에는 없다.
 *      그러나 다른파일, scope02-global에는 bookTest()가 있는 것이다.
 * 
 *    ----> 파일이 달라도 이것은 글로벌 오브젝트에 설정되기 때문에, 그리고 글로벌
 *          오브젝트는 하나만 존재하기 때문에 여기서 bookTest()를 호출할 때
 *    
 *    ----> 글로벌 오브젝트에 가서 식별자 해결을 하게된다. 그런데 이것이 있는 것이다.
 *          그리고 함수인 것이다. 그래서 호출할 수 있는 것이다.
 * 
 *    = 이것이 글로벌 오브젝트의 특징이다. 이로인해서 파생되는 것이 있다.
 *      bookTest()함수를 호출하기 위해서는 우선 식별자 해결을 해야한다.
 *      그럼 식별자 해결을 위해서는 스코프가 필요하다. =
 * 
 *    ===== 바로 이 글로벌 오브젝트가 스코프인것이다.
 * 
 * 
 */