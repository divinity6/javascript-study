/**
  * 프로그램 설명문서 주석
  * 2021.04 07 수업
  * 
  *           ===== 스코프 목적 =====
  * 
  *   - 범위를 제한하여
  *   ----> 식별자를 해결하려는 것
  *   ----> 스코프에서 식별자를 해결한다.
  * 
  *   - 식별자 해결 Identifier Resolution
  *   ----> 변수 이름, 함수 이름을 찾는 것
  *   ----> 이때 스코프를 사용
  *   ----> 이름을 찾게 되면 값을 구할 수 있음
  *   ----> 크게는 이름을 설정하는 것도 식별자 해결
  * 
  *   - 스코프는 식별자 해결을 위한 것
  * 
  *   ---------------------------------------------------
  * 
  *   - 스코프의 사전적 의미는 범위, 영역이다
  *   ----> 즉, 영역에서 스코프를 해결하려는 것이 스코프의 목적이다.
  * 
  *   - 여기서 식별자 해결이란,
  *   ----> 변수 이름, 함수 이름을 찾는 것이다.
  *         ( 어디서 찾는가, 이때 스코프를 사용한다. )
  * 
  *   ----> 그런데 이름을 찾게 되면 값을 구할 수 있다.
  *         식별자 해결의 궁극적인 목적은 값을 구하는 데 있다.
  * 
  *   - 값을 구했는데 그 값이 함수이면 호출할 수 있고,
  *     값이 Number이면 사칙연산을 할 수 있는 것.
  *   ----> 따라서, 값을 구하는 것이 중요하다.
  * 
  *   - 한편, 식별자 해결을 크게는 이름을 설정하는 것도 해결이라고 하기도한다
  *     예) 변수 이름을 스코프에 등록했다. ( 이것은 나중에 사용하는데 목적이 있다. )
  *   ----> 그리고 다음에 검색을 통해 식별자를 찾는다.
  * 
  *   ----> 두 단계가 있는 것이다. 등록과 검색.
  *   ----> 이것을 총 칭해서 식별자 해결이라고 하는 것이다.
  * 
  *   - 식별자 해결은 [[등록과 검색]]으로 나눌 수 있다.
  * 
  *   - 그런데 스코프는 식별자 해결을 위해 있는 것이다.
  *     스코프를 위해 식별자 해결이 있는 것이 아니라 식별자 해결을 위해 스코프가 있는 것이다.
  * 
  *   ==================================================================================
  *   ==================================================================================
  * 
  *               ===== 스코프 설정 =====
  * 
  *   1. 엔진이 function book(){}을 만나면
  *   
  *   2. function 오브젝트를 생성하고
  * 
  *   3. 스코프를 설정한다
  *   ----> 생성한 function 오브젝트의
  *   ----> [[Scope]]에 스코프를 설정한다
  *   ----> 즉, 이때 스코프가 결정된다.
  * 
  *   4. JS의 스코프 설정 메커니즘이다.
  * 
  *   ----------------------------------------------------
  * 
  *   - 처음에 function 오브젝트 생성. 그리고 스코프 설정
  *   ----> 이때 생성한 function 오브젝트의 내부 프로퍼티인 [[Scope]]에 스코프를 설정한다.
  *   ----> 따라서, 이때 스코프가 결정된다.
  * 
  *   = 이렇게 function 오브젝트를 만나는 시점에 스코프를 만드는 것을 정적 스코프라고 한다. =
  * 
  *   - 반면, 함수를 호출할 때 스코프를 등록하는 것을 동적 스코프라고 한다.
  *   ----> 동적 스코프에서 함수를 만번 호출했다고 가정하겠다.
  *         그럼 스코프를 만번을 만들어야 한다.
  *   ----> 반면, 정적 스코프는 function 오브젝트를 생성할 때, 한번만 만들면 되기 때문에
  *         1 대 10000 이되는 것이다.
  *   ----> 즉, 효율성 측면에서 본다면 정적 스코프가 효율성이 좋다.
  * 
  *   - 이것이 자바스크립트의 스코프 설정 메커니즘이다.
  *   ----> 즉, function 오브젝트를 생성할 때 스코프를 결정한다라는 것.
  * 
  *   ==================================================================================
  *   ==================================================================================
  * 
  *   5. 마지막 줄에서 book() 함수를 호출한다.
  * 
  *   6. 엔진 컨트롤이 book 함수 안으로 이동한다.
  * 
  *   7. function get(){}을 만나게 되며
  *   ----> function 오브젝트를 생성한다
  * 
  *   8. 스코프를 설정한다
  *   ----> function 오브젝트의
  *   ----> [[Scope]]에 스코프를 설정한다.
  *   ----> 이때 스코프가 결정된다.
  * 
  *   9. get() 함수를 호출 한다.
  * 
  *   -----------------------------------------------------------------------
  * 
  *   - book 함수를 만나게 되어 엔진 컨트롤이 book()함수 안으로 이동하게 되면
  *     우선 함수안에서 함수 선언문을 찾는다.
  *   ----> 그럼 function get()을 찾을 수 있을 것이다.
  *         그러면 function 오브젝트를 생성한다.
  * 
  *   ----> 그리고 마찬가지로 스코프를 설정하게 되는데, 이때 function 오브젝트의
  *         내부프로퍼티인 [[Scope]]에다가 스코프를 설정하게 된다.
  * 
  *   ----> 이때, 스코프가 결정되며, 이를 정적 스코프라고 한다.
  * 
  *   - 여기의 스코프는 영역, 범위의 개념이다. get함수가 속한 영역,
  *     따라서, 스코프에 속한 변수를 get(){}함수에서 쉽게 검색할 수 있게 된다.
  * 
  *   - 이것이 스코프를 설정하는 단계와 목적이다.
  * 
  * 
  */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};


window.onload = function() {
      var value = 200;
      function book(){
            var point = 123;
            function get(){
                  console.log(point);
                  console.log(value);
            };
            debugger;
            get();
      };
      debugger;
      book();
};
/**
 *  질문 답변)
 *  book() 함수를 호출하면 함수 안으로 이동합니다.
 * 
 *  get() 함수 아래에 변수를 선언할 수 있으므로 
 *  get() 함수를 만나 Function Object를 생성할 때는 
 *  book() 함수 안에 작성한 변수들을 완전하게 알 수 없습니다. 
 * 
 *  == 따라서 get() 함수로 Function Object를 생성할 때 [[Scrope]]에 
 *  변수들을 설정할 수 없습니다. ==
 * 
 *  이때 get() 함수가 속한 스코프를(만) 바인딩합니다. 즉, get() 함수가 
 *  속한 book() 함수의 어드레스를(만) 참조할 수 있도록 묶습니다. 
 * 
 *  book() 함수 안의 변수/함수는 바뀔 수 있지만 바인딩한 book() 함수의 
 *  어드레스는 바뀌지 않습니다. 이것이 바인딩과 설정의 차이입니다. 
 * 
 *  get() 함수 외부는 바인딩하고 내부는 설정합니다
 *  get() 함수를 호출하는 시점에는 book() 함수의 변수/함수가 [[Scope]에 
 *  설정되어 있으므로 [[Scope]]를 끌어오면 book() 함수 안에 작성된 함수/변수를 사용할 수 있습니다. 
 * 
 *  이제는 말할 수 있습니다만, 참조보다는 바인딩이 더 가깝습니다. 
 *  왜냐하면 바인딩은 정적 스코프가 포함되어 있기 때문입니다
 * 
 *  get() Function 오브젝트를 생성할 때 스코프를 [[Scope]]에 바인딩한다는 것은, 
 *  이때 스코프가 결정된다는 뜻을 내포합니다.
 * 
 *  즉, 스코프가 바뀌지 않는다는 것으로 get() 함수를 호출할 때마다 
 *  단지 가져다가 사용하면 된다는 것입니다.
 * 
 *  이것을 정적 스코프라고 합니다.
 *  반면 참조는 get() 함수를 호출할 때마다 참조하는 스코프가 바뀔 수 있다는 뉘앙스가 풍깁니다.
 * 
 *  이것은 동적 스코프로 착각(오해)할 수도 있습니다. 
 *  이렇게 까칠하게(?) 짚을 필요는 없지만, 그래도 완전하게 표현하는 것이 나을 것 같습니다. 
 * 
 *  바인딩은 사용전의 처리이고 참조는 사용 시점입니다. 예를 들어 this가 참조하는 오브젝트를 바인딩한다. 
 *  이것은 나중에 this가 참조하는 오브젝트를 사용하기 위해서이다. 이런 뉘앙스입니다. 
 *  
 * 
 */