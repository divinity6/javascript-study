/**
 * 프로그램 설명문서 주석
 * 2021.04 13 수업
 *
 *           ===== 바인딩 =====
 *
 *     - 구조적으로 결속된 상태로 만드는 것
 *     ----> 대상 : 프로퍼티 이름
 *
 *     - 바인딩 목적
 *     ----> 스코프 설정, 식별자 해결
 *
 *     - 바인딩 시점 구분
 *     ----> 정적 바인딩(Lexical, Static Binding)
 *     ----> 동적 바인딩(Dynamic Binding)
 *
 *     ------------------------------------------------------
 *
 *     - 바인딩은 구조적으로 결속된 상태로 만드는 것이다
 *     ----> 바인딩의 대상은 프로퍼티 이름이다.
 *     ----> 여기서 프로퍼티는 {변수이름 : 값}, {함수이름 : 값}이다
 *
 *     ----> 그런데 값은 변하므로 이름이 대상이 된다.
 *           (이름은 바뀌지 않기 때문이다.)
 *
 *     - 바인딩의 목적은 스코프를 설정하고 식별자를 해결하는 것이다.
 *
 *     - 바인딩 시점의 구분은 정적, 동적 바인딩으로 나뉜다.
 *     ----> 정적 바인딩(Lexical, Static Binding)
 *     ----> 동적 바인딩(Dynamic Binding)
 *
 *     - 스코프는 정적 스코프, 동적 스코프라고 부른다
 *
 *   ==================================================================================
 *   ==================================================================================
 *
 *           ===== 정적, 동적 바인딩 =====
 *
 *     - 정적(렉시컬) 바인딩
 *     ----> 초기화 단계에서 바인딩
 *     ----> 함수 선언문 이름을 바인딩
 *     ----> 표현식(변수, 함수) 이름을 바인딩
 *
 *     - JS는 대부분 정적 바인딩
 *
 *     - 동적(다이나믹) 바인딩
 *     ----> 실행할 때 바인딩
 *     ----> eval() 함수, with 문
 *
 *     -----------------------------------------------------------------------
 *
 *     - 정적(lexical) 바인딩은 함수가 호출되었을 때,
 *       초기화 단계에서 바인딩 한다.
 *     ----> 이때, 함수 선언문의 이름을 바인딩하고,
 *           변수와 함수 이름을 바인딩 한다.
 *           (값은 중요하지 않다.)
 *
 *     - 자바스크립트는 대부분 정적 바인딩을 한다.
 *
 *     - 하지만 동적 바인딩하는 것이 있는데 이것은 실행할 때 바인딩 하는 것이다.
 *       width문과 eval()함수가 있다.
 *
 *     ----> width문은 with문 안에서 반복할 때 마다, 동적 바인딩을 하게된다.
 *           eval()함수는 파라미터에 작성된 문자열을 파싱,즉 해석한 후,
 *           실행할 때 마다, 바인딩을 하게되는 것이다.
 *
 *     ----> 왜냐하면 eval()은 문자열이기 때문에 정적으로 바인딩을 할 수 없다.
 *
 *   ==================================================================================
 *   ==================================================================================
 *
 *           ===== 바인딩 시점의 중요성 =====
 *
 *     - 바인딩 시점이 중요한 이유
 *     ----> 바인딩할 때 스코프가 결정되기 때문이다.
 *
 *     - function 오브젝트 생성 시점에 스코프가 결정된다
 *     ----> 스코프를 function 오브젝트의 [[Scope]]에 설정한다
 *     ----> 스코프가 변경되지 않는다
 *
 *     - 함수 안의 모든 함수의 스코프가 같다
 *     ----> function book() {
 *             var point= 100;
 *             function add() { point += 200 };
 *             function get() { return point };
 *           }
 *
 *   -----------------------------------------------------------------------
 *
 *   - 바인딩 시점이 중요한 이유는 바인딩할 때 스코프가 결정되기 때문에 그렇다.
 *     ( 매우 중요한 사항 :: 스코프가 결정된다라는 것. )
 *
 *   - function 오브젝트 생성 시점에 스코프가 결정된다.
 *     스코프를 function 오브젝트의 내부프로퍼티인 [[Scope]]에 설정한다.
 *   ----> 여기서 가장 중요한 것은 스코프가 변경되지 않는다라는 것이다.
 *         ( 한번 설정해 두면 변경되지 않는다라는 것. )
 *
 *   - 그래서 정적 스코프인 것이다.
 *     ( 함수를 100만번 호출해도 스코프는 변경되지 않는다라는 것 )
 *
 *   ----> 따라서 함수를 호출할 때마다 스코프를 동적으로 설정하는 것과는
 *         차이가 엄청나게 큰 것이다.
 *         ( 스코프가 변경되지 않는다라는 것은 굉장히 중요한 의미이다 )
 *
 *   - 함수안의 모든 스코프가 같다.
 *   ----> function book() {
 *             var point= 100;
 *             function add() { point += 200 };
 *             function get() { return point };
 *          }
 *   ----> book 함수 안에 add 함수와 get함수가 있다.
 *         그런데 add function 오브젝트를 생성하는 시점에
 *         스코프를 [[Scope]]에다가 설정하는 것이다.
 *
 *   - 즉, 내부프로퍼티인 [[Scope]]에
 *     var point= 100;
 *     function add() { point += 200 };
 *     function get() { return point };
 *     이것들이 설정된다.
 *
 *   - get()도 마찬가지로, function 오브젝트를 만드는 시점에
 *     위의 코드들을 내부프로퍼티인 [[Scope]]에다가 설정한다.
 *
 *   ----> 그런데, 이것을 정적으로 한다라는 것이다.
 *         function오브젝트를 만드는 시점에 하고나서 스코프가 변경되지
 *         않는다라는 것이다.
 *
 *   - 따라서 add 함수에서 point를 공유할 수가 있는 것이다.
 *     왜냐하면 여기서부터
 *     var point= 100;
 *     function add() { point += 200 };
 *     function get() { return point };
 *     여기까지가 하나의 스코프이기 때문이다.
 *
 *   - 이 환경을 내부프로퍼티인 [[Scope]]에 설정하기 때문에 그렇다.
 *     그리고 이것은 변경되지 않기 때문에 그렇다.
 *   ----> var 변수는 삭제할 수가 없는 것.(계속 남아있다라는 것)
 *   ----> 따라서, 공통변수, add()와 get()함수에서 계속 사용할 수 있다라는 것이다.
 *
 *
 *
 */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function (value) {
    console.log('--- ' + value + ' ---');
};

function coffee() {
    var point = 100;

    function addCoffee() {
        point += 200
    };

    function getCoffee() {
        return point
    };
    addCoffee();
    debugger;
    getCoffee();
}

coffee();

/**
 *          ===== 스코프 바인딩 =====
 *
 *    1. 마지막 줄에서 book() 함수 호출
 *    ----> 초기화 단계에서 함수와 변수 이름을
 *    ----> 선언적 환경 레코드에 바인딩
 *    ----> 발음 편의를 위해 레코드라고 부른다
 *
 *    2. function add( param ) { ... }
 *    ----> function 오브젝트 생성
 *    ----> add 함수가 속한 스코프(영역)를
 *          add 오브젝트의 [[Scope]]에 설정
 *    ----> add 이름을 레코드에 바인딩
 *
 *    3. var point = 100;
 *    ----> point 이름을 레코드에 바인딩
 *
 *    4. var get = function(){ ... }
 *    ----> get 이름을 레코드에 바인딩
 *
 *    5. 바인딩으로 함수와 변수의 식별자가 해결됨
 *
 */

function book() {
    debugger;
    var point = 100;

    function add(param) {
        point += param;
    };
    var get = function () {
        return point;
    };
    add(200);
    console.log(get());
    // :: 300
};
book();

/**
 *  ------------------------------------------------------
 *
 *  - book()함수 호출. 엔진컨트롤이 함수안으로 이동.
 *  ----> 그러면 이제 초기화 단계에서 함수와 변수 이름을 선언적
 *        환경 레코드에 바인딩한다.( 바인딩, 묶는 것 )
 *
 *  - " 바인딩 " 묶는 것이다. 값을 할당하는 것이아니라
 *    변수이름과 함수이름을 묶는 것이다.
 *
 *  - 이제 첫번째 돌때 function add를 만나게 된다.
 *    그럼 function 오브젝트를 생성하고 add함수가 속한 스코프(영역)을
 *    add function 오브젝트의 내부 프로퍼티인 [[Scope]]에다가 설정하는 것이다.
 *  ----> 그리고 add 이름을 선언적 환경 레코드에 바인딩 한다.
 *
 *  - 그러면 다시 처음으로 올라간다.( 더이상 함수 선언문이 없기 때문에... )
 *  ----> 그럼 point 100을 만나게 되고, point 이름을 레코드에 바인딩한다.
 *        이때, 값은 undefined로 설정된다.
 *
 *  ----> 그리고 쭉 내려오면 get이 있고, 그러면 get과 undefined로 레코드에 바인딩한다.
 *        여기까지 함으로 써, 바인딩이 끝난 것이다.
 *
 *  ==== 그러면 이때, 함수와 변수의 식별자가 해결된다. ====
 *
 *  - 비록 변수는 값이 다를 지언정 변수 이름이 없어서 에러가 나지는 않는다.
 *  ----> 값은 다음이야기다. 왜냐하면 실행하지 않은 상태와 실행한 상태와는 다르기 때문이다
 *
 */

/**
 *
 *          ===== 스코프 바인딩2 =====
 *
 *    ----------- 코드 실행 -----------
 *
 *    6. var point = 100;
 *    ----> point 변수에 100 할당
 *
 *    7. var get = function(){ ... }
 *    ----> function 오브젝트 생성, get에 할당
 *    ----> get 함수가 속한 스코프(영역)를
 *          get 오브젝트의 [[Scope]]에 설정
 *
 *    ----------- add() 함수 호출 -----------
 *
 *    8. add(200) 함수를 호출한다.
 *    9. point += param;
 *    ----> 먼저 레코드에서 point 이름을 찾는다
 *    ----> point가 없으므로 다시 검색하게 되며
 *    ----> add 오브젝트의 [[Scope]]를 스코프로 사용한다.
 *    ----> book 오브젝트가 스코프이며
 *          point가 있으므로 값을 더한다.
 *
 *
 *
 *    ------------------------------------------------------
 *
 *    - function 오브젝트를 만나 get에다 할당한다.
 *      그리고 이것도 마찬가지로 get이 속한 영역을( 스코프를 )
 *    ----> get function 오브젝트의 내부프로퍼티인 [[Scope]]에다가 설정한다.
 *
 *    - add 함수호출(), add안으로 이동.
 *      그러면 point += param;코드를 만나게 되고,
 *      이때, point는 먼저, 선언적 환경 레코드에서 찾는다.
 *    ----> 그것(선언적 환경 레코드)은 무엇이 들어가 있는가?
 *    ----> 함수 안에 작성된 함수와 변수가 그곳에 들어가 있다.
 *
 *    ----> 그래서 먼저 레코드에서 찾고, 그런데 없다. add function안에 선언되지 않았으니...
 *          그러면 다시 검색하게 된다.
 *
 *    ----> 그러면 어디가서 찾는가? add function 오브젝트의 내부프로퍼티인 [[Scope]]에 가서
 *          이것(내부프로퍼티인 [[Scope]])을 스코프로 사용해서 검색하게 된다.
 *
 *    ----> 그런데 있기 때문에, point 값을 사용할 수가 있는 것이고 파라미터에 값을 넘겨줘
 *          300이 되는 것이다.
 *
 *    - 내가만든 변수가 아니라 함수 밖에 있는것도 값을 변경할 수 있는 것이다.
 *    ----> 왜냐? 함수가 속한 스코프를 내부프로퍼티인 [[Scope]]에다가 설정해 놓고,
 *          마치 내것처럼 쓰기 때문에 그렇다.
 *
 *    ----> 사실 point는 add함수의 소유는 아니다. 왜냐면 밖에 있기 때문에
 *          (소유라면 안에 작성해야 하기 때문...)
 *
 *    - 밖에 있는데도 안에 있는것처럼 사용할 수 있는 메커니즘은
 *      내부 프로퍼티 [[Scope]]에 스코프를 설정하기 때문에 그렇다.
 *
 *
 *
 */


/**
 *
 *          ===== 스코프 바인딩3 =====
 *
 *
 *    ----------- get() 함수 호출 -----------
 *
 *    10. get() 함수를 호출한다.
 *    11. return point;
 *    ----> 선언적 환경 레코드에 point가 없으므로 다시 검색한다.
 *    ----> get 오브젝트의 [[Scope]]를 스코프로 사용한다
 *    ----> book 오브젝트가 스코프이며 point가 있으므로 값을 반환한다.
 *
 *    -------------------------------------------------------------
 *
 *    - 그리고 console.log로 get 호출.
 *    ----> 그런데 안에 point가 없다. 함수안에 point를 선언하지 않았다.
 *    ----> 그러면 이것을 어디에서 찾는가?
 *
 *    - 내부 프로퍼티인 Scope에서 찾는다. 그런데 있다. 이 값이 300인 것이다.
 *      그래서 300을 출력을 하게된 것이다.
 *
 *    ===== 여기서 point 변수를 add 함수와 get 함수에서 공유했다라는 것 =====
 *
 *    - 왜냐, 이것이 같은 스코프를 갖기 때문에 그렇다.
 *
 */

/**
 *
 *          ===== 동적 바인딩 ======
 *
 *    - 코드를 실행할 때마다 바인딩
 *    ----> width 문
 *    ----> eval() 함수
 *
 *    - with 문
 *    ----> "use strict" 환경에서 에러 발생
 *
 *    - eval() 함수
 *    ----> 보안에 문제 있음.
 *
 *    ------------------------------------------------------------
 *
 *    - 동적 바인딩이란 코드를 실행할 때마다 바인딩 하는 것이다.
 *      with문과 eval()함수.
 *
 *    - with문을 쓰지말고 for ~ in문을 한번더 전개시키면 된다.
 *      ( 따라서 이것은 대안이 있기 때문에 사용하지 않아도 된다 )
 *
 *    - eval()함수는 어쩔 수 없다. 문자열로 처리하기 때문.
 *      (보안에 문제가있으면 친하게 지내면 안된다.)
 *
 */


/**
 *
 *  질문의 내용)  book() 함수에서 point 변수를 식별할 때는 선언적 환경 레코드에 설정됩니다.
 *  반면, add() 함수 안에서는 book() 함수 안에 작성된 모든 변수가
 *  외부 렉시컬 환경 참조에 설정됩니다. 따라서 point 변수의 해결 시점과
 *  사용 위치에 따라 다릅니다
 *
 *
 *  함수 안에 작성된 모든 변수와 함수는 선언적 환경 레코드에 설정됩니다.
 *  이때 식별자가 함수이면, book 함수 안의 모든 변수와 함수
 *  (함수도 이때는 식별자로 처리됩니다)를 [[scope]]에 설정하고,
 *  여기서는 add() 함수. 그리고 add() 함수가 호출되면 add 함수의
 *  [[scope]]에 설정된 것을 add 함수의 외부 렉시컬 환경 참조에
 *  설정하여 참조합니다. 또한 add() 함수 안에는 변수와 함수가
 *  없으므로 선언적 환경 레코드에는 아무것도 설정되지 않습니다.
 *
 *
 *
 */