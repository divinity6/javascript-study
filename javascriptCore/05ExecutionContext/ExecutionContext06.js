/**
  * 프로그램 설명문서 주석
  * 2021.05 04 수업
  * 
  *           ===== 호출 스택(call stack) =====
  *   
  *   - call stack
  *   ----> 실행 콘텍스트의 논리적 구조
  * 
  *   - First In Last Out 순서
  *   ----> 함수가 호출되면 스택의 가장 위에
  *         실행 콘텍스트가 위치하게 된다.
  * 
  *   ----> 다시 함수 안에서 함수를 호출하면
  *         호출된 함수의 실행 콘텍스트가
  *         스택의 가장 위에 놓이게 된다.
  * 
  *   ----> 함수가 종료되면 스택에서 빠져 나온다(FILO 순서)
  * 
  *   - 가장 아래는 글로벌 오브젝트의 함수가 위치해있다.
  * 
  *   - call stack 형태
  * 
  *   ------------------------------------------------------------------
  * 
  *   - call stack은 실행콘텍스트의 논리적 구조이다.
  *   ----> 계단 식으로 만드는 것.
  *   ----> 그런데 First In Last Out 순서이다.
  * 
  *   ----> 함수가 호출되면 스택의 가장 위에 실행 콘텍스트가 위치하게 된다.
  *         예) one을 호출하면 one이 가장 위에 올라가는 것.
  *             (아래가 아님)
  * 
  *   ----> 그리고 다시 함수안에서 함수를 호출하면, 호출된 함수의 실행 콘텍스트가
  *         스택의 가장 위에 놓이게 된다.
  *         예) one을 호출하면 one이 가장 위에있다가 
  *             two를 호출하면 two가 가장위로 올라간다.
  * 
  *   == 따라서, 가장 위에 있는 것이, 실행하고 있는 함수이며, 실행 콘텍스트인 것이다. ==
  * 
  *   ----> 그러면 two에서 three를 호출하고 three에서 이제 나간다.
  *         이것이 빠져나가면 stack에서 내려오게 된다.
  * 
  *   - 함수가 종료되면 stack에서 빠져나오게 된다.(여기서 First In Last Out) 순서
  *   ----> 즉 최종적으로 호출된 것이 먼저 나오게 된다.
  * 
  *   = 그러나! 이런 논리가 되는 것은 자바스크립트는 싱글 스레드 이기 때문에 그렇다 =
  * 
  *   - 실행하는 루트가 하나다. 길이 하나밖에 없는 것이다.
  *   ----> 그렇기 때문에 이런 논리가 성립이 되는 것이다.
  *         ( 만약, 쓰레드가 2개면 이런 논리가 성립하지 않는다 )
  * 
  *   - 따라서, 가장 마지막에는 글로벌 오브젝트의 함수가 위치하게 된다.
  * 
  */

console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};

log('call stack');

function one() {
  two();
  console.log(1);
}

function two(){
  three();
  console.log(2);
};
function three(){
  console.log(3);
}
one();
// :: 3 2 1


/**
 *          ===== callStack 구조 형태 =====
 * 
 *  - window.onload 안에 작성.
 *  ----> 이것의 뜻은 안에 작성한 것들이
 *        글로벌 오브젝트에 포함되게 된다.
 * 
 *  ----> 그러면 찾아가기가 너무 힘들다
 * 
 *  ----> 따라서, 지역변수안에서 찾아가기 쉽게하기
 *        위해서 onload 이벤트를 이용한 것일 뿐이다.
 */


window.onload = function(){
  "use strict"
  debugger;
  
  function setMain(){
    function one(){
      two();
      console.log(1);
    };
    function two(){
      three();
      console.log(2);
    };
    function three(){
      console.log(3);
    };
    one();
  };
  setMain();

};

/**
 *    - 왼쪽 callStack에 window.onload 이벤트가 있다.
 *      (이것이 아래 위치하게 된다.)
 *    - 이것이 먼저 호출되었기 때문이다. 
 *      (그후 디버거 위치에서 슴)
 * 
 *    - 그리고 setMain을 호출하게 된다
 *      그러면 setMain이 callStack 상단에 위치하게 된다.
 *      (그리고 load는 아래로 내려가게 된다)
 * 
 *    - 맨상단의 화살표표시가 실행중인 것이다.
 * 
 *    - 그리고 다시 one을 호출하면 one이 올라가게 되고
 *      two를 호출하면 two가 다시 올라가게 되는 것이다.
 * 
 *    - 그래서 먼저 호출된 것이 자꾸 자꾸 아래로 내려가게
 *      되는 것이다.
 * 
 *    - 가장 위에 있는 것이 현재 실행중인 것이다.
 * 
 *    - 그리고 다시찍고 리턴하게 되면 three가 내려간 것.
 * 
 *    - 그리고 계속실행해서 찍고 내려가면 Call Stack에서
 *      사라진다.
 * 
 *    - 이 논리의 바탕은 바로 싱글 스레드이다.
 * 
 * 
 * 
 */