/**
  * 프로그램 설명문서 주석
  * 2021.05 10 수업
  * 
  *           ===== 파라미터 값 할당 기준 =====
  * 
  * 
  * 
  *   - 지금까지 퍼즐을 맞춰온것.
  *     실행콘텍스트의 프로퍼티,오브젝트를 어떻게 논리적으로 접근할 것인가.
  *     그리고 그것의 퍼즐을 맞춰나갈 때 다음 퍼즐은 어떻게 논리적으로 접근할 것인가.
  * 
  *   - 전체적인 퍼즐. (파라미터 값 할당기준도 퍼즐 맞추기)
  *     단, 논리적으로 접근하는 것.
  * 
  * 
  * 
  * 
  * 
  * 
  * 
  *     - 아래의 설명을 따라가며 { key : value } 형태로 만들어 보기
  * 
  *   -----------------------
  *         초기화 단계
  *   -----------------------
  * 
  *   1. obj.getTotal( 11 , 22 ) 함수가 호출되면
  *   ----> 파라미터 값을 실행 콘텍스트로 넘겨준다
  *         
  * 
  *   2. 파라미터 이름에 값을 매핑하여
  *   ----> 선언적 환경 레코드에 설정한다.
  *   ----> { one : 11 , two : 22 }
  *         (여기까지는 앞에서 다루었다)
  * 
  *   3. var one;
  *   ----> 선언적 환경 레코드에서 one의 존재를 체크
  *   ----> 파라미터 이름을 설정하였으므로 존재하며
  *   ----> one을 기록하지 않는다.
  * 
  *   4. two = 77;
  *   ----> 선언적 환경 레코드에서 two의 존재를 체크
  *   ----> 파라미터 이름을 설정하였으므로 존재하며
  *   ----> two를 기록하지 않는다.
  * 
  *   5. 함수에 초기화할 코드가 없다.
  *   ----> 첫 번째 줄로 이동하여 함수 코드를 실행한다.
  * 
  *   -------------------------------------------------------------------
  * 
  *   - 초기화 단계에서 안으로 파라미터에 값을 매핑하여 선언적 환경 레코드에 설정한
  *     후 선언적 환경 레코드에서 one이 있는지 체크를 한다.
  * 
  *   ----> 그런데 선언적 환경 레코드에 있다.( 파라미터를 설정하면서 설정해두었다. )
  *         초기화 단계이기 때문에 값은 undefined이다.
  * 
  *   ----> 그런데 one: 11이 있기때문에 var one;이것을 무시한다.
  *         즉, 11이 그대로 유지되고 undefined로 대체되지 않는다. (초기화의 특징)
  *   
  *   ----> 그리고 two가 있다. two, 우선 선언적 환경레코드에서 식별자 해결을 하게된다.
  *         two앞에 variable을 작성하지 않았다.
  * 
  *   ----> 그런데 선언적 환경레코드에서 찾는다. 그리고 없으면 그다음의 처리를 하게
  *         되는 것이다. ( var이 없다고 무조건적으로 글로벌 변수인 것은 아닌 것이다. )
  * 
  *   - two의 존재를 체크했는데 이미 있다. 그러면 그것을 replace시키지 않고 넘겨버린다.
  *     
  *   ----> 즉, 기존에 있는 two : 22가 그대로 유지되고 있는 것이다.
  * 
  *   ----> 그리고나서 초기화할 코드가 없기때문에 첫번째 줄로 이동해서 함수코드를
  *         실행하게 되는 것이다.
  * 
  * 
  *   ==================================================================================
  *   ==================================================================================
  * 
  *   -----------------------
  *         실행 단계
  *   -----------------------
  * 
  *   6. 선언적 환경 레코드는 현재
  *      { one : 11 , two : 22 } 상태
  * 
  *   7. var one;
  *   ----> 단지, 변수 선언이므로 처리하지 않는다.(실행이 아닌 것.)
  * 
  *   8. console.log( one + two );
  *   ----> 선언적 환경 레코드에서
  *   ----> one과 two의 값을 구한다.
  *   ----> 11 + 22의 결과인 33이 [ 실행 결과 ]에 출력된다.
  * 
  *   9. two = 77;
  *   ----> 값을 할당하는 코드이며 실행 단계이므로
  *   ----> 선언적 환경 레코드의 two에 77을 할당하며
  *   ----> { two : 22 }가 { two : 77 }로 변경된다.
  *         ( 초기화할때는 아니지만 실행 단계에서는 파라미터 이름도 
  *         하나의 프로퍼티 개념으로 접근하는 것이다. )
  * 
  *   10. console.log( " two : " + two );
  *   ----> 선언적 환경 레코드에서 two의 값을 구한다.
  *   ----> [ 실행 결과 ]에 two : 77이 출력된다.
  * 
  * 
  *   -------------------------------------------------------------------
  * 
  *   - 파라미터이름이 실행 단계에서는 
  *     선언적 환경 레코드에 존재하는 하나의 식별자의 개념이된다.
  * 
  *   - 그런데, 기본적으로 파라미터 이름을 (함수안에서 변수이름, 값재할당등으로... ) 
  *     사용하지 않는것이 좋지만,
  *     ( 신경써야 할것들이 있을때 )
  *     가끔은 파라미터 값을 함수안에서 변경할 때가 있다.
  * 
  *   - 그럴때는 선언적 환경 레코드에서 처리되는 과정을 정확하게 이해해야 한다.
  * 
  */

console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};

log('파라미터 값 할당 기준');

var obj = {};

obj.getTotal = function( one, two ) {
  var one;
  console.log( one + two );

  two = 77;
  console.log( "two :" + two );
};
obj.getTotal( 11 , 22 );


log('정리시간');

/**
 *          ===== 정리시간 =====
 * 
 *  - 아래 코드를 기준으로
 *    엔진관점에서 [ 실행 결과 ]에 출력된 값의
 *    논리를 제시.
 * 
 *    ----> 함수의 파라미터 값이 매핑되는 과정을
 *    ----> { key : value } 형태로 기술하고
 *    ----> 값이 출력되는 논리를 생각(기술)하기.
 * 
 * 
 *  - 힌트 :
 *  ----> 두 번째, 세 번째 파라미터 이름이 같다.
 * 
 */
debugger;
var obj2 = {  point : 100 };

obj2.getTotal = function( one , two , two ){
  
  console.log( one + two );
  return this.point;
};
obj2.getTotal( 11 , 22, 55 );

/**
 *  0.초기화단계에서 obj2를 { obj2 : undefined } 형태로 바인딩한다.
 *    
 *  1.그 후 실행단계에서 obj2에 object를 할당한다.
 * 
 *  2.obj2.getTotal을 만나면 getTotal : function오브젝트를 설정한 후
 *    주변환경의 변수와 함수등의 스코프를 getTotal 내부의
 *    [Scope]에 바인딩하고,   
 *    또 getTotal내부안의 [[FormalParameters]]에다가 파라미터이름을 매핑한다.
 *    그리고 내려와서 obj2.getTotal( 11, 22, 55 )를 만나 함수를 호출하게 되면
 * 
 *  3.실행 콘텍스트를 만들고 getTotal( 11 , 22 , 55 )를
 *    실행 콘텍스트에 값으로 넘겨준다.
 *    그리고 [[FormalPrameters]]에서 함수의 
 *    파라미터 이름을 [ one , two , two ]형태로 구한다.
 * 
 *  4.그 후 name을 하나씩 읽어 가면서 파라미터 값을 index순으로 구하고
 *    순서대로 매핑한다.
 *  
 *  5.그 다음 실행콘텍스트안 렉시컬환경컴포넌트의 환경레코드의 선언적 환경레코드안에
 *    바인딩한다.
 *    { one : 11 , two : 22 },
 *    그런데 중복되는 이름(two)이 있기 때문에 이름은 바뀌지 않고 값만
 *    { one : 11 , two : 55 }, 형태로 변경한다.
 *    또한 getTotal앞에 작성되어 있는 오브젝트인 obj2를 this 바인딩 컴포넌트에
 *    바인딩한다.
 * 
 *  6.그리고 엔진 컨트롤이 함수안으로 이동하여 [초기화 단계]에 진입한다.
 *    내부에 초기화할 변수 및 함수가 없기 때문에 실행단계로 넘어간다
 *    ( 이때는 값이 있으면 대체되지 않는다. )
 *  
 *  7.실행 단계에서는 console.log를 만나 내부의 선언적 환경레코드에 바인딩되어있는
 *    {one : 11과 tow : 55}를 통해 식별자를 해결하고 값을 구한다.
 *    
 */