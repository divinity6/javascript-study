/**
  * 프로그램 설명문서 주석
  * 2021.04 22 수업
  * 
  *           ===== 렉시컬 환경 컴포넌트 =====
  * 
  *   - 함수와 변수의 식별자 해결을 위한 환경 설정
  * 
  *   - 함수 초기화 단계에서 해석한
  *   ----> 함수와 변수를 { name : value } 형태로 저장
  *   ----> 이름으로 함수와 변수를 검색할 수 있게 된다.

  * 
  *   - 함수 밖의 함수와 변수 참조 환경 설정
  *   ----> 함수 밖의 함수와 변수를 사용할 수 있게 된다.
  * 
  *   -------------------------------------------------------
  * 
  *   - 렉시컬 환경 컴포넌트란 함수와 변수의 식별자 해결을 위한 환경을 설정한다
  *   ----> 그리고 함수 초기화 단계에서 해석한 함수와 변수를 
  *         { name : value } 형태로 저장
  * 
  *   ----> 변수는 name과 undefined로 저장이 되고 선언문은
  *         name과 function 오브젝트로 저장이 된다.
  * 
  *   ----> 이렇게 함으로써 함수와 변수를 검색할 수 있게 된다.
  *         즉, 식별자 해결을 할 수 있게 되는 것이다.
  * 
  *   - 함수 밖의 함수와 변수를 참조할 수 있는 환경을 설정한다
  *   ----> 즉, 내가 속한 오브젝트의 환경을 이곳에다 설정하는 것.
  * 
  *   ----> 따라서, 렉시컬 환경컴포넌트 안에서 함수 밖의 함수와 변수를
  *         사용할 수 있게 된다.
  * 
  *   - 즉, 하나의 컨텍스트가 되는 것이다.
  *     함수 밖에 있는것과 함수안에있는 것을 하나의 묶음으로 
  *     렉시컬 환경 컴포넌트에다가 만들어 버리는 것이다
  * 
  *   ----> 그럼으로써 심플해진다.(프로그램을 이범위내에서만 작성한다면..)
  * 
  *  ==================================================================================
  *  ==================================================================================
  * 
  *           ===== 렉시컬 환경 컴포넌트 구성 =====
  * 
  *             실행 콘텍스트(EC): {
  *               렉시컬 환경 컴포넌트(LEC) : {
  *                 환경 레코트(ER): {
  *                   point: 100
  *                 }
  *               },
  *               외부 렉시컬 환경 참조(OLER): {
  *                 title: "책",
  *                 getTitle: function(){}
  *               }
  *             }
  * 
  * 
  *   - 렉시컬 환경 컴포넌트 생성
  *   ----> function, with, try-catch에서 생성
  * 
  *   - 컴포넌트 구성
  *   ----> 환경 레코드
  *         ER: Environment Record
  * 
  *   ----> 외부 렉시컬 환경 참조
  *         OLER: Outer Lexical Environment Reference
  * 
  *   -------------------------------------------------------
  *   
  *   - 렉시컬 환경 컴포넌트를 생성하는데 실행 콘텍스트에다 첨부시킨다.
  *   ----> 이것을 언제 만드는가?
  *         function, with, try-catch를 만났을때 
  *         렉시컬 환경 컴포넌트를 생성한다.
  * 
  *   ----> 컴포넌트 구성은 환경 레코드와 외부 렉시컬 환경 참조가 있다.
  *         그리고 그안에 변수와 함수가 설정되어 있다.
  *         ( 물론 환경레코드는 한단계 더 내려갈 수 
  *         있지만 가독성을 위해 환경레코드만 작성 )
  * 
  *  ==================================================================================
  *  ==================================================================================
  *  
  *           ===== 렉시컬 환경 컴포넌트 설정 =====
  * 
  *             실행 콘텍스트(EC): {
  *               렉시컬 환경 컴포넌트(LEC) : {
  *                 환경 레코트(ER): {
  *                   point: 100
  *                 }
  *                 외부 렉시컬 환경 참조(OLER): {
  *                   title: "책",
  *                   getTitle: function(){}
  *                 }
  *               },
  *
  *             }
  * 
  * 
  * 
  *   - 환경 레코드에
  *   ----> 함수 안의 함수와 변수를 기록
  * 
  *   - 외부 렉시컬 환경 참조에
  *   ----> function 오브젝트의 내부프로퍼티인 [[Scope]]를 설정
  *         (이것은 우리가 function 오브젝트를 만나서 )
  * 
  *   - 따라서 함수 안과 밖의 함수와 변수를 사용할 수 있게 된다
  * 
  *   -------------------------------------------------------
  *   
  *   - 외부 렉시컬 환경 참조에
  *   ----> function 오브젝트의 내부프로퍼티인 [[Scope]]를 설정
  *         
  *   ----> 이것은 우리가 function 키워드를 만나서 function 오브젝트를
  *         만들 때 설정 했다.
  * 
  *   ----> 함수가 호출되면 [[Scope]]를 외부렉시컬 환경 참조에 설정한다는
  *         이야기이다.
  * 
  *   - 렉시컬 환경 컴포넌트 입장에서 보면 ER과 OLER은 하나의 오브젝트에
  *     속하는 것이다. 즉,!! 덩어리인 것이다.
  *     묶음이다.!! 콘텍스트다.!!
  * 
  *   ----> 함수안에 작성된 함수와 변수를 환경레코드(ER) 안에다 기록해놨다
  *         그러면 이것도 묶음 안에서 사용할 수 있다.
  * 
  *   ----> 그리고 함수밖의 [[Scope]]]를 외부 렉시컬 환경 참조(OLER)에
  *         설정 해 두었다.
  *         이것도 렉시컬 환경 컴포넌트(LEC) 오브젝트안에 들어있는 것이다.
  *         (묶음.)
  * 
  *   - 따라서 함수 안과 밖의 함수와 변수를 하나의 묶음, Context 개념으로,
  *     사용할 수 있게 되는 것이다.(매우 중요)
  * 
  *   ----> 그래서 우리가 프로퍼티에 악세스하듯이 
  *         그냥 악세스할 수 있다는 것이다.
  * 
  *   ----> 실행 콘텍스트 밖으로 나갈 이유가 없다는 것이다.
  *         (프로그램만 이 규칙을 지켜서 짜준다면)
  * 
  *   - 그러면 엔진은 아주 간단하게 이 안에서 처리할 수 있다는 것이다.
  * 
  *   - 엔진처리가 심플하다는 이야기는 처리시간이 빠르다는 이야기다(바로 이것이다.)
  * 
  *   ==================================================================================
  *   ==================================================================================
  *   
  *           ===== 외부 렉시컬 환경 참조 =====        
  * 
  *             실행 콘텍스트(EC): {
  *               렉시컬 환경 컴포넌트(LEC) : {
  *                 환경 레코트(ER): {
  *                   point: 100
  *                 }
  *               },
  *               외부 렉시컬 환경 참조(OLER): {
  *                 title: "책",
  *                 getTitle: function(){}
  *               }
  *             }
  * 
  *   - 스코프와 실행중인 함수가 Context 형태이므로
  *   ----> 스코프의 변수와 함수를
  *   ----> 별도의 처리 없이 즉시 사용할 수 있다.
  * 
  *   - 실행 콘텍스트에서
  *   ----> 함수 안과 밖의 함수, 변수를 사용할 수 있으므로
  *   ----> 함수와 변수를 찾기 위해
  *   ----> 실행 콘텍스트를 벗어나지 않아도 된다.
  * 
  *   -------------------------------------------------------
  *   
  *   - 스코프와 실행중인 함수가 Context 형태이다.
  *   ----> 외부 렉시컬 환경 참조(OLER)은 함수가 속한 스코프인 것이다.
  *   ----> 그리고 실행중인 함수가 환경레코드(ER)안에 다 들어와 있다.(코드가)
  * 
  *   - 그러므로 하나의 Context가 되는 것이다.(묶음)
  *   ----> 따라서 스코프의 변수와 함수를
  *   ----> 별도의 처리 없이 즉시 사용할 수 있다.
  *   
  *   ----> 왜냐하면 OLER에 있는데 밖으로 나갈필요도 없고 끌고 올 필요도 없다.
  * 
  *   - 그래서 실행콘텍스트에서
  *   ----> 함수 안과 밖의 함수, 변수를 사용할 수 있으므로
  *   ----> 함수와 변수를 찾기 위해
  *   ----> 실행 콘텍스트를 벗어나지 않아도 된다.
  *         ( 다른곳에서 끌고오지 않아도 된다. )
  * 
  *   - 실행 콘텍스트가 메모리에 올라가 있는데
  *   ----> 메모리를 들락날락 거리면 그것은 처리시간에 영향을 끼치게 된다.
  *         (따라서 한번 메모리에 올라갔으면 메모리안에서 처리하겠다라는 것.)
  *   ----> 이것이 실행 콘텍스트의 렉시컬 개념인 것이다.
  * 
  *   - this 참조는 뒤에서 다룬다.
  * 
  * 
  *   ==================================================================================
  *   ==================================================================================
  *   
  *           ===== 변수 환경 컴포넌트 =====
  * 
  *             실행 콘텍스트(EC): {
  *               렉시컬 환경 컴포넌트(LEC) : { },
  *               
  *               변수 환경 컴포넌트(VEC) : { },
  * 
  *               this 바인딩 컴포넌트(TBC) : { }
  *             }
  * 
  *   - 실행 콘텍스트 초기화 단계에서
  *   ----> 렉시컬 환경 컴포넌트와 같게 설정한다.
  * 
  *   - 이렇게 하는 이유는?
  *   ----> 초깃값을 복원할 때 사용하기 위한것.
  * 
  *   - 함수 코드가 실행되면
  *   ----> 실행 결과를 렉시컬 환경 컴포넌트에 설정
  *   ----> 초기값이 변하게 되므로 이를 유지하기 위한 것
  * 
  *   -------------------------------------------------------
  * 
  *   - 변수환경 컴포넌트는 LEC와 같은 레벨이다.
  * 
  *   - 실행 콘텍스트 [[초기화 단계]]에서,
  *   ----> 이 초기화 단계가 한번돌고 두번돌고 하는 것.
  *   ----> 이때, 렉시컬 환경 컴포넌트와 같게 설정한다.
  * 
  *   - 렉시컬 환경 컴포넌트가 처리의 메인이다.
  *   ----> 그런데 LEC에 설정된것을 VEC에 설정한다라는 것
  *   ----> 이렇게 하는 이유는 초깃값을 복원할 때 사용한다라는 것이다.
  * 
  *   - 함수안의 코드가 실행되면
  *   ----> 실행 결과를 렉시컬 환경 컴포넌트에 설정한다라는 것이다.
  *   ----> 예) 변수에다 값을 할당. 
  *         그런데 현재 초기값상태에서는 변수가 { key : undefined }
  *         상태로 되어있다.
  *   ----> 그런데 값을 할당했다는 이야기는 변수값이 바뀌었다는 이야기다.
  * 
  *   - 그러면 그것은 바로 렉시컬 환경에 설정된다.
  *   ----> 그러면 한번만 값을 설정하게 되면 LEC와 VEC는 값이 다를 것이다.
  *         그런데 나중에 LEC에 있는 것을 지우고 초기환경으로 바꾸려고 한다.
  * 
  *   ----> 그럴때는 VEC로 갔다가 LEC를 replace시켜버리면 된다.
  *         그런 용도로 사용하는 것이 VEC이다.
  * 
  *   - 그러면 VEC은 언제 사용하느냐?
  *   ----> with문에서 사용한다.
  * 
  * 
  *    
  */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};
