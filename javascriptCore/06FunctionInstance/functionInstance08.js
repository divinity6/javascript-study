
/**
 * 프로그램 설명문서 주석
 * 2021.06 16 수업
 *
 *
 *           =====인스턴스 프로퍼티 =====
 *
 *      -------------------------------
 *      obj 인스턴스 = {
 *          point : 100,
 *          getPoint : function(){},
 *          __proto__: {
 *              getPoint : function(){}
 *          }
 *      }
 *
 *      -------------------------------
 *
 *
 *
 *      - prototype에 연결된 프로퍼티도
 *      --> 인스턴스 프로퍼티가 된다
 *      --> 직접 인스턴스에 연결된 프로퍼티와
 *          차이가 있다.
 *
 *      - 인스턴스의 프로퍼티를
 *      --> prototype으로 만든
 *      --> 인스턴스 프로퍼티보다 먼저 사용한다.
 *
 *      - 인스턴스마다 값을 다르게 가질 수 있다.
 *      --> 인스턴스를 사용하는 중요한 목적
 *
 *      ----------------------------------------
 *      obj.getPoint 형태로 호출하는 형태를 인스턴스 프로퍼티라고 한다.
 *      한편, 직접인스턴스에 연결된 프로퍼티와는 차이가 있다.
 *
 *      인스턴스의 프로퍼티를 먼저사용한다.
 *      즉, __proto__안에 넣어서 사용하는것은 인스턴스의 프로퍼티를 먼저
 *      사용하기 위한 것이다.
 *      즉, obj.getPoint를 하면 __proto__위에있는 직접 호출한 프로퍼티가 먼저 호출된다
 *      === 대체할 수 있는 것이다 ===
 *      ( 인스턴스마다 값을 다르게 가질 수 있다. 인스턴스의 특징 )
 */



console.log("=====================================");

"use strict"
// console.log 사용
var log = function (value) {
    console.log('--- ' + value + ' ---');
};

/**
 *      
 *           =====인스턴스 프로퍼티 우선 사용 =====
 *           
 *      1. Book.prototype.getPoint = function(){
 *          return 100;
 *      };
 *      - prototype에 getPoint를 연결한다.
 *      - 인스턴스의 getPoint()를 호출하면 100을 반환한다.
 *
 *      2. obj.getPoint = function(){
 *          return this.point;
 *      };
 *      - 생성한 인스턴스에 getPoint를 연결한다.
 *      - 함수가 호출되면 200을 반환한다.
 *      
 *      3. obj 인스턴스 구성 형태
 *      ------------------------------------------
 *      obj 인스턴스 = {
 *          getPoint : function(){return this.point},
 *          __proto__: {
 *              getPoint: function(){return 100;}
 *          }
 *      }
 *      ------------------------------------------
 *      
 *      4. obj.getPoint();
 *      - obj 인스턴스의 getPoint() 호출
 *      - prototype의 getPoint()가 호출되지 않고
 *        인스턴스의 getPoint()가 호출된다.
 *        
 *      5. 인스턴스의 프로퍼티는 공유되지 않는다
 *      
 *      6. Class 접근
 *      - 설계가 중요하다
 *      - OOP 개념 이해 필요
 *
 */

log('인스턴스 프로퍼티 우선 사용');

function Book(point) {
    // 인스턴스를 만들때마다 이값들은 인스턴스의 값으로 대체됨
    this.point = point;
}

// 그러나 메소드들은 공유됨
Book.prototype.getPoint = function(){
    return 100;
}
var obj = new Book(200);

// 인스턴스에 바로 연결되어 있는 getPoint.
// 호출되면 구조적으로 위부터 아래로 찾아가기때문.
obj.getPoint = function(){
    return this.point;
};
debugger;
console.log(obj.getPoint());

/**
 *      인스턴스를 사용하는 목적을 좀더 깊게 생각해보자.
 *
 *      ES5에서는 Class 키워드를 지원하지 않지만, 형태는 위의 Book 형태가
 *      Class 형태이다.
 *      위의 형태에 getPoint, setPoint등등등을 연결하게 된다.
 *      (그러면 하나의 클래스 형태가 됨)
 *
 *      - 그러면 왜 클래스를 만드냐라는 것.
 *      --> 인스턴스는 메소드의 프로퍼티의 묶음이다.
 *          ( 이렇게 하나로 묶는 이유는, 데이터 중심으로 접근하겠다라는 뜻이다. )
 *
 *      위의 Book형태에서 data만 넘겨주면
 *      var obj = new Book(200)에서 파라미터가 200이지만,
 *      배열이들어올수도있고 object가 들어올 수도 있다.
 *
 *      즉,이렇게 인스턴스마다 값을 가져가겠다라는 것이다.
 *
 *      [[데이터 중심]]으로 접근하겠다라는 것이 키워드이다.
 *
 *      예) A라는 사람이 책을 샀다. 그러면, 그사람도 point를 별도로 관리해야 하지만,
 *          getPoint 메소드가 필요한 것이다.
 *
 *          그리고 내가 책을 샀다. 그럼 내 point도 필요하지만, getPoint도 필요하다.
 *          그러면 point 점수는 다르지만, point점수를 구하는 메소드는 똑같다.
 *          (바로 이것이 데이터 중심이다)
 *
 *          데이터만 다르게가고 메소드는 똑같이 가겠다라는 것.
 *
 *          함수를 만약 이런형태로 간다면, 별도의 어떤 저장하는 장치가 필요하다.
 *          (왜냐면 함수안에다 저장할 수 없기 때문이다.)
 *          - 함수 호출시 값이 지워지기 때문.
 *          - 그러나 인스턴스로 가져가면 인스턴스마다 값을 별도로 가져갈 수 있다.
 *
 *      - 그런데 이렇게 Class적으로 접근하려면 설계가 중요하다.
 *        (함수는 개별 기능단위로 펼쳐두면된다.)
 *      - 그러나 Class 접근은 주차타워, 시스템이 만들어져야한다.
 *        (이것은 설계가 동반된다. - 그런데 설계를 하려면 객체지향 프로그래밍에대한 이해가 필요)
 *
 *      - 자바스크립트는 객체지향언어다.
 *        ( 시스템이 복잡해지면 어쩔수없이 객체지향으로 가야한다 )
 */


















