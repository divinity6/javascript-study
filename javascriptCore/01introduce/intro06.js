/**
  * 프로그램 설명문서 주석
  * 2021.03 22 수업
  * 
  *           ===== 정적 환경 =====
  * 
  *     - function 키워드를 만나면
  *     ----> function 오브젝트를 생성하고
  *     ----> 스코프를 FO의 [[Scope]]에 설정
  *     ----> 이것은 함수 밖의 스코프가 설정 되는 것이다.
  * 
  *     - 이 시점에서 스코프가 결정된다
  *     ----> 이것이 Lexical Environment 이다
  * 
  *     - 함수가 호출되면
  *     ----> FO의 [[Scope]]를
  *     ----> 실행 콘텍스트의 렉시컬 환경 컴포넌트의 외부 렉시컬 환경 참조에 설정한다.
  * 
  *     ------------------------------------------------------------------------------
  * 
  *     - function 키워드를 만나면 function 오브젝트를 생성하고 스코프를 FunctionObject의
  *       스코프에 설정한다.
  * 
  *       따라서 함수 밖의 스코프가 설정되는 것이다. 함수 안은 들어가지 않았으니 아직 모른다
  * 
  *     - 이시점에서[[ 함수밖의 스코프가 결정]]되는 것이다. 이것이 바로 정적 환경이다.
  *       function 키워드를 만났을 때, 함수밖의 scope가 결정된다는 것이다.
  * 
  *     - 함수를 호출 할때 결정되는 것이 아니라 function 키워드를 만났을 때 결정된다라는 것.
  * 
  *       그래서 동적이 아니라 Lexical! 정적인 것이다.
  * 
  *     - 또한 함수가 호출되면 Function Object에 설정된 [[Scope]]를 실행콘텍스트의
  *       렉시컬 환경 컴포넌트의 외부 렉시컬환경 참조에 설정한다.
  *       (렉시컬 환경 = 이안엔 선언적 환경 레코드가 있다.)
  * 
  *     - 렉시컬 환경이다. 이안에 또하나가 무엇이 있는가 하면 선언적 환경레코드가 있다
  *       그것이 무엇인가 하면 함수가 호출되어 있을 때 함수 안에 작성된 변수와 함수가
  *       들어있는 것이다.
  * 
  *       따라서 함수 밖에 있는 변수와 함수, 함수안에있는 변수와 함수를 하나의 렉시컬,
  *       즉, 정적 개념으로 사용할 수 있다.       
  * 
  *     == 따라서 하나의 콘텍스트이다. 우리가 프로그램을 여기에 맞춰서 작성한다면
  *        메모리를 들락날락하거나, 다른 처리를 하거나, 그럴 필요가 없다.
  * 
  *     == 그렇다면 매우 빠르게 엔진이 처리 할 수 있다.
 *         (즉, 너무깊은 단계까지 끌고다니게 되면 엔진처리가 느려짐)
  * 
  * 
  */
console.log("=====================================");

"use strict"
// console.log 사용
var log = function( value ){
  console.log('--- ' + value +' ---');
};


window.onload = function() {
  function a(){
    var point = 123;
    function book() {
      function getPoint(){};
    };
    debugger;
    
    // function getPoint(){
    //   // 애가 있어야만 [[scopes]]에 나오네
    //   return point;
    // };
    book();

    debugger;
  }
  a();


/*
          ===== var 키워드 문제 =====
          
    - 함수에서 var 키워드를 사용하지 않고
    ----> 변수를 선언하면 글로벌 오브젝트에 설정된다.
    ----> 렉시컬 환경 구조에 맞지 않는다

    - ES5 해결 방법
    ----> "use strict" 사용

    - ES6 해결 방법
    ----> let 변수, const 변수
    ----> 변수 자체에 스코프 제약을 둔다.
  
  -------------------------------------------------------

  - 함수에서 variable 키워드를 사용하지 않고 변수를 선언하면 글로벌
    오브젝트에 설정된다. 

    그러면 함수안의 몇단계 내려가서 var 키워드를 사용하지 않고 변수를
    선언했다. 그럼 몇단계위에 있는 글로벌오브젝트에 설정된다.

    그러면 이것은 scope chain 개념으로 가야한다.

  - 왜냐하면 지금 lexical 환경은 함수 밖에 있는 것과, 함수 안에 있는,
    두개 단계의, 계층만 가지고 있는데 이것을 몇단계올라간다.
    그래서 그것을 다가지고 끌고 다니게 된다. 그러면 그것은 Lexical 환경
    구조에 맞지 않는다.

  - 그래서 ES5에서는 "use strict"를 사용하는 것으로 이것을 보완시켰다.
  - 왜냐하면 "use strict"환경에서는 var 키워드를 선언하지 않고 변수를
    선언하면 에러가 난다. 
    그러나 이때, 사실은 빠르게 코딩하다보니 var를 놓친것이다.

    그런데도 실행하게 되면 문제가 없이 실행되니 간과하게 된다.

    그런 부분들을 카바 하기 위한 것.

    따라서 ES5환경에서는 소스코드 처음에 "use strict"를 작성하는 것은
    필수 아닌 필수라고 할 수 있다.

  - 한발 더 나아가서 ES6에서는 let 변수와 const 변수를 사용해서 조금더
    근본적으로 var 키워드를 사용하지 않아서 생기는 정적환경 구조의 문제를
    해결하고 있는 것이다.
  
  - 즉, 변수자체에 스코프에 대한 제약을 둠으로써 근본적으로 렉시컬 환경을
    유지하겠다라는 것이다.
*/


/*
          ===== 동적 환경 =====

    - 실행 시점에서 스코프 결정
    ----> with 문
    ----> eval() 함수

    - with 문은
    ----> strict 모드에서 에러 발생

    - eval() 함수는
    ----> 보안에 문제가 있다.

  ------------------------------------------------------------------

  - 그런데 자바스크립트는 정적환경만 있는 것이 아니다.
    동적 환경도 있다.

  - 동적환경은 실행하는 시점에 스코프가 결정된다.
    지금까지 우리는 function 키워드를 만나면 그때 스코프가 결정됐다.

    이것이 정적이었다.

  - 그러나 with문은 with문을 반복할 때 마다 scope가 만들어 진다.
    이것이 동적인 것이다.

  - 그러면 엔진은 부담이 된다. 왜냐면 한번만 정적으로 만들면 scope가 결정됐는데
    with문을 만번을 돈다. 그러면 만번을 scope를 만들어야 한다,
    이것은 부담이지 않는가?

  - 그리고 eval() 함수가 있다. eval() 함수는 문자열 가지고 하니깐 이건 대책이 없다.

  - 그러나 with()는 "use strict"모드에서 에러가 발생한다.
     "use strict"를 작성하면 with문은 에러가 발생하니깐 동적환경에서 처리되는 부분들을
     보완할 수가 있다,

  - 그리고 eval()함수는 다른각도로 보안에 문제가 있다.
    보안에 문제가 있으면 되도록이면 피하는 것이 좋다.
    (eval 함수는 마지막에 쓰는 카드이다.)

*/
};
